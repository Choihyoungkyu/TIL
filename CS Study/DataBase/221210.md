# 221210



## 관계 데이터 모델

- 개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델
- 하나의 개체에 대한 데이터를 하나의 릴레이션에 저장

![image-20221210151530919](images/2_1.PNG)



#### 관계 데이터 모델의 기본 용어

- 릴레이션 (relation)
  - 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것
  - 파일 관리 시스템 관점에서 파일(file)에 대응
- 속성 (attribute)
  - 릴레이션의 **열**, 애트리뷰트
  - 파일 관리 시스템 관점에서 필드(field)에 대응
- 튜플 (tuple)
  - 릴레이션의 **행**
  - 파일 관리 시스템 관점에서 레코드(record)에 대응

- 도메인 (domain)
  - 하나의 속성이 가질 수 있는 모든 값의 집합
  - 속성 값을 입력 및 수정할 때 적합성의 판단 기준이 됨
  - 일반적으로 속성의 특성을 고려한 데이터 타입으로 정의
- 널 (null)
  - 속성 값을 아직 모르거나 해당되는 값이 없음을 표현
- 차수 (degree)
  - 하나의 릴레이션에서 속성의 전체 개수
- 카디널리티 (cardicality)
  - 하나의 릴레이션에서 튜플의 전체 개수



#### 릴레이션의 구성

- 릴레이션 스키마 (relation schema)
  - 릴레이션의 논리적 구조
  - 릴레이션의 이름과 릴레이션에 포함된 모든 속성 이름으로 정의
    - ex) 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금)
  - 릴레이션 내포(relation intension)라고도 함
  - 정적인 특징이 있음
- 릴레이션 인스턴스 (relation instance)
  - 어느 한 시점에 릴레이션에 존재하는 튜플들의 집합
  - 릴레이션 외연 (relation extension)이라고도 함
  - 동적인 특징이 있음



#### 데이터베이스의 구성

- 데이터베이스 스키마 (database schema)
  - 데이터베이스의 전체 구조
  - 데이터베이스를 구성하는 릴레이션 스키마의 모음
- 데이터베이스 인스턴스 (database instance)
  - 데이터베이스를 구성하는 릴레이션 인스턴스의 모음



#### 릴레이션의 특성

- 튜플의 유일성
  - 하나의 릴레이션에는 동일한 튜플이 존재할 수 없다
- 튜플의 무순서
  - 하나의 릴레이션에서 튜플 사이의 순서는 무의미하다
- 속성의 무순서
  - 하나의 릴레이션에서 속성 사이의 순서는 무의미하다
- 속성의 원자성
  - 속성 값으로 원자 값만 사용할 수 있다



#### 키 (key)

- 릴레이션에서 튜플들을 유일하게 구별하는 속성 또는 속성들의 집합
- 종류
  - **기본키 (primary key)**
    - 후보키 중에서 기본적으로 사용하기 위해 선택한 키
      - 널값을 가질 수 있는 속성이 포함된 후보키는 부적합
      - 값이 자주 변경될 수 있는 속성이 포함된 후보키는 부적합
      - 단순한 후보키를 선택
  - **대체키 (alternate key)**
    - 기본키로 선택되지 못한 후보키
  - **외래키 (foreign key)**
    - 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
    - 릴레이션들 간의 관계를 표현
      - 참조하는 릴레이션 : 외래키를 가진 릴레이션
      - 참조되는 릴레이션 : 외래키가 참조하는 기본키를 가진 릴레이션
  - **슈퍼키 (super key)**
    - **유일성**을 만족하는 속성 또는 속성들의 집합
  - **후보키 (candidate key)**
    - **유일성**과 **최소성**을 만족하는 속성 또는 속성들의 집합

- 특성
  - 유일성 (uniqueness)
    - 하나의 릴레이션에서 모든 튜플은 서로 다른 키 값을 가져야 함
  - 최소성 (minimality)
    - 꼭 필요한 최소한의 속성들로만 키를 구성



#### 무결성 제약조건 (integrity constraint)

- 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
- 무결성 : 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것



#### 개체 무결성 제약조건 (entity integrity constraint)

- 기본키를 구성하는 모든 속성은 널 값을 가질 수 없다



#### 참조 무결성 제약조건 (referential integrity constraint)

- 외래키는 참조할 수 없는 값을 가질 수 없다

---



## 관계 데이터 모델링 : 실습

#### 설계 3 단계 : 논리적 설계

- 목적
  - DBMS에 적합한 논리적 스키마 설계
  - 개념적 스키마를 논리적 데이터 모델을 이용해 논리적 구조로 표현
    - 논리적 모델링 (데이터 모델링)
    - 일반적으로 관계 데이터 모델을 많이 이용
- 결과물
  - 논리적 스키마 : 릴레이션 스키마
- 주요 작업
  - 개념적 설계 단계의 결과물인 E-R 다이어그램을 릴레이션 스키마로 변환
  - 릴레이션 스키마 변환 후 속성의 데이터 타입, 길이, 널 값 허용 여부, 기본 값, 제약조건 등을 세부적으로 결정하고 결과를 문서화시킴

- E-R 다이어그램을 릴레이션 스키마로 변환하는 규칙

  1. 모든 개체는 릴레이션으로 변환한다.

     - 개체의 이름 -> 릴레이션 이름
     - 개체의 속성 -> 릴레이션의 속성
     - 개체의 키 속성 -> 릴레이션의 기본키
     - 개체의 속성이 복합 속성인 경우에는 복합 속성을 구성하고 있는 단순 속성만 릴레이션의 속성으로 변환

  2. 다대다(n:m) 관계는 릴레이션으로 변환한다.

     - 관계의 이름 -> 릴레이션 이름
     - 관계의 속성 -> 릴레이션의 속성
     - 관계에 참여하는 개체를 규칙 1에 따라 릴레이션으로 변환한 후 이 릴레이션의 기본키를 관계 릴레이션에 포함시켜 외래키로 지정하고 외래키들을 조합하여 관계 릴레이션의 기본키로 지정

  3. 일대다(1:n) 관계는 외래키로 표현한다.

     - 1측 개체 릴레이션의 기본키를 n측 개체 릴레이션에 포함시켜 외래키로 지정

     - 일반적인 일대다 관계는 외래키로 표현
     - 약한 개체가 참여하는 일대다 관계는 외래키를 포함해서 기본키로 지정
       - 약한 개체는 오너 개체에 따라 존재 여부가 결정되므로 오너 개체의 기본키를 이용해 식별해야 함

  4. 일대일(1:1) 관계는 외래키로 표현한다.

     - 일반적인 일대일 관계는 외래키로 표현
     - 일대일 관계에 필수적으로 참여하는 개체의 릴레이션만 외래키를 받는다
     - 모든 개체가 일대일 관계에 필수적으로 참여하면 릴레이션을 하나로 합친다

  5. 다중 값 속성은 릴레이션으로 변환한다.

     - 다중 값 속성과 함께 그 속성을 가지고 있던 개체 릴레이션의 기본키를 외래키로 가져와 새로운 릴레이션에 포함시킴
     - 새로운 릴레이션의 기본키는 다중 값 속성과 외래키를 조합하여 지정

- 기타 고려 사항

  - 모든 관계를 독립적인 릴레이션으로 변환 가능
    - 속성이 많은 관계는 유형에 상관없이 릴레이션으로의 변환을 고려할 수 있음
  - 개체가 자기 자신과 관계를 맺는 순환 관계도 기본 규칙을 적용

---



## 이상현상과 함수종속

#### 이상(anomaly) 현상

- 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입, 수정, 삭제 연산을 수행할 때 발생할 수 있는 부작용



#### 이상현상의 종류

- 삽입 이상 (insertion anomaly)
  - 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
- 갱신 이상 (update anomaly)
  - 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
- 삭제 이상 (deletion anomaly)
  - 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제



#### 정규화

- 이상 현상을 제거하면서 데이터베이스를 올바르게 설계해 나가는 과정
- 이상 현상이 발생하지 않도록, 릴레이션을 관련 있는 속성들로만 구성하기 위해 릴레이션을 분해(decomposition)하는 과정
- **함수의 종속성**을 판단하여 정규화를 수행함



#### 함수의 종속성 (FD : Functional Dependency)

- 속성들 간의 관련성
- 함수 종속성을 이용하여, 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해하여 이상 현상이 발생하지 않는 바람직한 릴레이션으로 만들어 나가는 과정이 정규화



#### 함수 종속

- 릴레이션 내의 모든 튜플을 대상으로 하나의 X값에 대한 Y값이 항상 하나임
- X와 Y는 하나의 릴레이션을 구성하는 속성들의 부분 집합
- **X -> Y**로 표현 (X는 결정자, Y는 종속자)



#### 함수 종속 관계 판단 시 유의 사항

- 속성 자체의 특성과 의미를 기반으로 함수 종속성을 판단해야 함
  - 속성 값은 계속 변할 수 있으므로 현재 릴레이션에 포함된 속성 값만으로 판단하면 안됨
- 일반적으로 기본키와 후보키는 릴레이션의 다른 모든 속성들을 함수적으로 결정함
- 기본키나 후보키가 아니어도 다른 속성 값을 유일하게 결정하는 속성은 함수 종속 관계에서 결정자가 될 수 있음



#### 완전 함수 종속 (FFD : Full Functional Dependency)

- 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X의 전체가 아닌 일부분에는 종속되지 않음을 의미
- 일반적으로 함수 종속은 완전 함수 종속을 의미함
- ex) 당첨여부는 {고객 ID, 이벤트번호}에 완전 함수 종속됨



#### 부분 함수 종속 (PFD : Partial Functional Dependency)

- 릴레이션에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미
- ex) 고객이름은 {고객 ID, 이벤트번호}에 부분 함수 종속됨



#### 이행적 함수 종속 (transitive FD)

- 릴레이션을 구성하는 세 개의 속성 집합 X, Y, Z에 대해 함수 종속 관계 X -> Y와 Y -> Z가 존재하면 논리적으로 X -> Z가 성립되는데, 이것을 Z가 X에 이행적으로 함수 종속되었다고 함



#### 고려할 필요가 없는 함수 종속 관계

- 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않음

