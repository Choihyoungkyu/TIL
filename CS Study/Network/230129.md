# 230129

#### 목차

1. TCP Model
2. 세션, 쿠키, 토큰
3. 주소창에 웹 주소를 쳤을 때 생기는 일
4. HTTP와 HTTPS의 차이
5. 프록시 서버가 필요한 이유와 작동 과정

---



## TCP Model

#### TCP (Transmission Control Protocol, 전송 제어 프로토콜)

- **서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜**
- 데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜
- 데이터는 네트워크선로를 통해 전달되는 과정에서 손실되거나 순서가 뒤바뀌어서 전달될 수 있는데, TCP는 손실을 검색해내서, 이를 교정하고 순서를 재조합할수 있도록 해준다
  => TCP는 순서를 보장해준다
- 역할 : 에러 없이 패킷이 신뢰할 수 있게 전달되었는지 보증해줌
- 동시제어 가능 = 초기 요청이 작게 시작하거나 컴퓨터들과 서버들의 대역폭의 깊이가 증가해도 네트워크 지원 가능



#### 등장 배경

- IP Address 패킷 전달의 한계점 극복을 위해
  - (비연결성) 패킷을 받을 대상이 연결 상태임을 확인하지 않고 전송하기 때문에 받을 대상(호스트)이 서비스 불능 상태여도 패킷이 전송된다
  - (전송제어 정보 없음) 순서가 있는 여러 개의 데이터를 보냈을 때 받는 데이터가 같은 순서로 받아질 것이란 보장이 안된다
  - (전송제어 정보 없음) 패킷을 가지고 있던 호스트가 강제종료되어 패킷이 소실된 경우 패킷이 목적지까지 가지 못하고 소실될 수 있다



#### TCP의 역할

1. 받을 대상 노드(호스트)가 서비스 가능(연결 가능) 상태인지 확인 및 연결을 수립하는 역할
2. 전송을 제어해주는 정보를 패킷에 추가해주는 역할
   - ex) 중간에 빠진 패킷이 있거나, 중간에 빠진 정보가 있을 시 요청자에게 해당 패킷을 다시 보내도록 요청하여 데이터 전달 보증 또한 가능하게 만들어준다



#### TCP의 특징

1. **신뢰성**
   - TCP는 손상되거나 없어지거나 중복되거나 네트워크 계층에서 순서가 틀어져서 전달된 데이터를 복구하기 위해 **적극적 수신, 통지, 재전송 체계**를 사용
2. **흐름 제어**
   - TCP 데이터 세그먼트를 송수신하는 컴퓨터는 CPU와 네트워크 대역폭의 차이 때문에 서로 다른 데이터 속도로 작동할 수 있는데, TCP는 송신자가 보낸 데이터의 양을 제어하는 흐름 제어 메커니즘을 구현하여 송수신 속도를 맞춘다
3. **다중화**
   - 한 라우터의 많은 프로세스가 TCP 통신 서비스를 동시에 사용 가능
     - TCP를 사용하는 응용프로그램에 포트 번호 값을 연계하여 사용
4. **연결형 서비스**
   - 응용 프로그램 프로세스는 TCP를 사용하여 데이터를 보낼 수 있는 상태가 되려면 먼저 연결을 설정해야 함
5. **TCP 연결은 데이터를 양방향으로 운반할 수 있다**
   - 하나의 전송선로에서 데이터가 동시에 양쪽방향으로 전송 가능
6. **TCP 연결은 3way handshake 절차를 사용하여 열린다**
   - SYN과 ACK 플래그를 사용
     - SYN = 1 && ACK = 0 : 연결 열기 패킷
       - 어플리케이션이 서버에 통신을 위한 연결을 요청
     - SYN = 1 && ACK = 1 : 연결 열기 수신 통지
       - 서버가 어플리케이션에 자신이 활성 상태임을 알리고 어플리케이션도 포트를 열어 연결을 활성화하라는 요청 메시지를 전송
     - SYN = 0 && ACK = 1 : 데이터 패킷 or ACK 패킷
       - 어플리케이션이 서버의 요청 메세지를 수락하여 연결이 수립
   - 연결을 설정하는 절차는 동기화(SYN) 제어 플래그를 이용하며, 3way handshake라는 세 메시지를 교환하여 연결



#### 각 플래그 별 설명

- **URG (Urgent)**

  - Urgent pointer 필드에 값이 채워져있음을 알림
    - 송신측 상위계층이 긴급 데이터이면, 긴급비트를 1로 설정하고, 순서에 상관없이 먼저 송신
    - 긴급 데이터의 마지막 바이트 위치가 Urgent pointer로 가리켜짐

- **ACK (Acknowledgement)**

  - 확인응답 필드에 확인응답번호(Acknowledgement Number) 값이 세팅됐음을 알림
    - 1 : 확인번호 유효함
    - 0 : 확인번호 미포함 (즉, 32비트 크기의 확인응답번호 필드 무시됨)

  - SYN 세그먼트 전송 이후(TCP 연결 시작 후) 모든 세그먼트에는 항상 이 비트가 1로 세팅됨

- **PSH (Push)**

  - 버퍼링된 데이터를 가능한한 빨리 상위 계층 응용프로그램에 즉시 전달할 것
    - 수신측은 버퍼가 찰 때까지 기다리지 않고, 수신 즉시 버퍼링된 데이터를 응용프로그램에 전달
  - 때론, 서버측에서 더이상 전송할 데이터가 없음을 나타내기도 함

- **RST (Reset) [강제 연결 초기화 용도]**

  - 연결확립(ESTABLISHED)된 회선에 강제 리셋 요청
    - 강제 리셋 : RST = 1 (RST 세그먼트 또는 RESET 세그먼트)
  - 연결 상의 문제를 발견한 장비가 RST 플래그를 '1'로 설정한 TCP 세그먼트를 송출
    - LISTEN, SYN, RCVD 상태일 때 => RST 수신한 경우 => LISTEN 상태로 들어감
    - 그 밖의 상태일 때 => RST 수신한 경우 => 연결 끊고 CLOSED 상태로 들어감

- **SYN (Synchronize) [연결시작, 회선개설 용도]**

  - TCP 연결설정 초기화를 위한 순서번호의 동기화 => TCP 연결 설정
    - 연결요청 : SYN = 1, ACK = 0 (SYN 세그먼트)
    - 연결허락 : SYN = 1, ACK = 1 (SYN+ACK 세그먼트)
    - 연결설정 : ACK = 1 (ACK 세그먼트)
  - 즉, 송수신 간에 순서번호의 동기화

- **FIN (Finish) [연결해제, 회선종결 용도]**

  - 송신기가 데이터 보내기를 끝마침 => TCP 연결 종료
    - 종결요청 : FIN = 1 (FIN 세그먼트)
    - 종결응답 : FIN = 1, ACK = 1 (FIN+ACK 세그먼트)

---



## 세션, 쿠키, 토큰

#### 세션, 쿠키의 등장 배경

- HTTP 통신의 특징 때문
  1. Connectionless 프로토콜 (비연결 지향)
     - 클라이언트가 서버에 요청했을 때, 요청에 맞는 응답을 보낸 후 연결을 끊는 처리방식
  2. Stateless 프로토콜 (상태정보 유지 안함)
     - 클라이언트의 상태 정보를 가지지않는 서버 처리 방식
     - 클라이언트와 첫번째 통신에 데이터를 주고 받았다 해도, 두번째 통신에 이전 데이터를 유지하지 않는다



#### 쿠키

- 쿠키는 공개 가능한 정보를 사용자의 브라우저에 저장시킴
- 클라이언트 측에 정보를 저장
- 보안과 관련 없는 장바구니, 자동로그인 설정 같은 경우에 유용하게 사용됨



#### 세션

- 비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고, 대신 사용자의 식별자인 session id를 저장
- 서버 측에 정보를 저장
- 데이터 매칭에 오랜 시간 소요, 서버에 부하
- **사용자는 쿠키를 이용하고, 서버에서는 쿠키를 받아 세션의 정보를 접근하는 방식으로 인증해야함**



#### 쿠키 + 세션의 장단점

- 장점
  - 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고 있지 않음 -> 중요한 정보는 서버 세션에 존재
  - 고유한 ID 값을 발급 받음
    - 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지 확인할 수 있어 서버의 자원에 접근하기 용이함
- 단점
  - 세션 하이재킹 공격 가능
    - 해결책 : HTTPS를 사용해 요청 자체를 탈취해도 안의 정보를 읽기 힘들게 하거나, 세션에 유효시간을 부여할 수 있음
  - 서버에서 추가적은 저장공간이 필요
    - 서버에서 세션 저장소를 사용하므로 부하가 높아짐



#### 토큰 (JWT)

- 인증에 필요한 정보들을 암호화시킨 토큰을 의미
- 사용자는 Access Token을 HTTP 헤더에 실어 서버에 전송
- 토큰은 **임의로 생성된 비밀번호** 같이 동작
- 제한된 수명을 가지고, 새로운 토큰은 한번 만료되면 새로 생성되어야 함 (refresh Token)



#### JWT의 특징

1. **More Compact**
   - JSON으로 인코딩 하기 때문에 XML로 인코딩하는 SAML 토큰보다 작다
2. **More Secure**
   - JWT는 공개키와 개인키를 나누어 서명
   - HMAC 암호 알고리즘을 사용하여 암호화된 서명도 가능
3. **More Common**
   - JSON의 object는 일반적인 프로그래밍 언어이기 때문에 접근성이 좋음
4. **Erasier to process**
   - JWT는 인터넷 규모로 사용됨 -> 모바일에서 처리가 더 쉬움



#### 토큰의 구조

1. **Header**
   - JWT를 검증하는데 필요한 정보를 가진 JSON 객체는 Base64 URL-Safe 인코딩된 문자열
   - 헤더는 JWT를 어떻게 검증(veriify)하는가에 대한 내용을 담고 있음
   - **alg** : 서명시 사용하는 알고리즘
   - **kid** : 서명시 사용하는 키(public/private key)를 식별하는 값
   - `Encoded Header + "." + Encoded Payload + "." + Verify Signature`
2. **Payload**
   - JWT의 내용
   - 페이로드에 있는 속성들을 클레임 셋(Claim Set)이라고 부름
   - 토큰 생성자의 정보, 생성일시 등 JWT에 대한 내용 + 데이터로 구성
3. **Signature**
   - 점(.)을 구분자로 해서 헤더와 페이로드를 합친 문자열을 서명한 값



#### 토큰의 장단점

- 장점
  - header와 payload를 가지고 signature를 생성하므로 데이터 위변조를 막을 수 있다
  - 인증 정보에 대한 별도의 저장소가 필요없다 => 서버 부하 감소
  - JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증되었다는 서명 등 필요한 모든 정보를 자체적으로 가지고 있다
  - 토큰은 한번 발급되면 유효기간이 만료될때까지 계속 사용 가능
  - 확장성이 뛰어나다 => 소셜 로그인
- 단점
  - 쿠키나 세션과 다르게 JWT는 토큰의 길이가 길어 인증 요청이 많아질수록 네트워크 부하가 심해진다
  - payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보를 담으면 안된다
  - 토큰을 탈취당하면 대처하기 어렵다
  - 특정 사용자의 접속을 강제로 만료하기 어렵지만, 쿠키/세션 기반 인증은 서버 쪽에서 쉽게 세션을 삭제할 수 있다



#### 세션/쿠키 vs 토큰

- 세션/쿠키는 세션 저장소에 유저 정보를 넣는 반면, JWT는 토큰 안에 유저의 정보들이 넣어진다는 점이 가장 큰 차이점
- 클라이언트 입장에서는 HTTP 헤더에 세션 ID나 토큰을 실어서 보내준다는 점에서 동일
- 서버 입장에서는 인증을 위해 암호화를 한다 vs 별도의 저장소를 이용한다 의 차이가 발생

---



## 주소창에 웹 주소를 쳤을 때 생기는 일

1. **브라우저의 URL 해석 / 파싱**

   - https : 프로토콜
   - www.naver.com : Domain Name
   - 443 : Port
   - 어떤 프로토콜을 사용할 것인지, 어떤 URL로 서버에 요청을 보낼 것인지, 어떤 포트번호로 요청할 것인지 해석

2. **DNS 서버에서 IP 주소 받아오기 (URL -> IP Address)**

   - DNS (Domain Name System) : 도메인 이름 URL을 IP 주소로 변경해줌

3. **라우터를 이용해 접속하려는 네트워크로 가는 최적의 경로 찾기**

   - DNS에게 얻은 IP 주소는 동일한 네트워크 안에 위치하고 있지 않다
   - 따라서 라우터를 통해 해당 서버의 게이트웨이를 찾아 우리가 원하는 서버의 네트워크로 이동해야함

4. **DNS 서버에서 응답 받은 IP 주소를 MAC 주소로 변환 (APR)**

   - IP 주소와 MAC 주소의 차이점

     - IP 주소를 통해 해당 IP 서버가 있는 곳이 로컬 네트워크가 아닌 경우, 그 지역 라우터까지 패킷이 전달됨
     - 라우터에서는 IP 주소에 해당하는 컴퓨터가 누군지 알아내기 위해 MAC 주소가 필요함
     - 즉, 접속하려는 서버의 네트워크를 찾기 위해 IP 주소를 사용하고, 그 네트워크 내부에 있는 컴퓨터와 통신하기 위해 MAC 주소가 필요

   - APR (Address Resolution Protocol)

     - 논리주소인 IP 주소를 물리주소인 MAC 주소로 변환해주는 역할

     1. 송신측은 목적지의 MAC 주소가 필요하므로 APR 요청 패킷을 **브로드캐스트 방식**으로 전달
     2. 모든 Host와 Router는 송신자가 보낸 APR 요청을 수락
     3. 해당되는 수신자만 자신의 IP 주소와 MAC 주소를 넣어 응답

5. **TCP 소켓 통신**

   - **3-way-handshake**를 통해 TCP 소켓 연결
   - HTTPS의 경우 3-way-handshake + TLS(Transport Layer security, SSL) handshake가 추가됨

6. **HTTPS(HTTP) 프로토콜 요청 / 응답**

   - TCP 소켓 연결이 완료된 후 naver.com 페이지를 서버에 요청
   - 서버는 응답을 받고, 응답이 가능하다면 브라우저에게 해당 요청에 대한 응답을 생성(HTML, CSS, JS)하여 전달

7. **브라우저가 응답**

   - 응답(HTML, CSS, JS 등)을 받은 브라우저는 웹 페이지를 표시



[참고] HSTS

- HSTS의 리스트에 우리가 요청할 웹 사이트가 존재하는지 확인 후 존재한다면 브라우저가 HTTP 대신 HTTPS 프로토콜을 사용하여 요청을 보내게 함

---



## HTTP와 HTTPS의 차이

#### HTTP (Hyper Text Transfer Protocol)

- 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜
- Port : 80
- 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동
- 상태를 가지고 있지 않는 Stateless 프로토콜이며, Method, Path, Version, Headers, Body 등으로 구성



#### HTTPS (Hyper Text Transfer Protocol Secure)

- HTTP에 데이터 암호화가 추가된 프로토콜
- Port : 443
- 네트워크 상에서 중간에 제3자가 볼 수 없도록 암호화를 지원



#### 대칭키 암호화와 비대칭키 암호화

- **대칭키 암호화**
  - 클라이언트와 서버가 동일한 키를 사용해 암호화/복호화를 진행
  - 키가 노출되면 매우 위험하지만 연산 속도가 빠름
- **비대칭키 암호화**
  - 1개의 쌍으로 구성된 공개키와 개인키를 암호화/복호화 하는데 사용
  - 키가 노출되어도 비교적 안전하지만 연산 속도가 느림
  - 공개키 암호화 : 공개키로 암호화를 하면 개인키로만 복호화 가능 -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다
  - 개인키 암호화 : 개인키로 암호화를 하면 공개키로만 복호화 가능 -> 공개키는 모두에게 공개되어 있으므로, 내가 인증한 정보임을 알려 신뢰성 보장 가능



#### HTTPS 동작 과정

- 대칭키 암호화와 비대칭키 암호화를 모두 사용하여 빠른 연산 속도와 안정성을 모두 얻음

1. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함
2. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행



#### HTTPS의 발급 과정

1. A 기업은 HTTP 기반의 애플리케이션에 HTTPS를 적용하기 위해 공개키/개인키를 발급함
2. CA 기업에게 돈을 지불하고, 공개키를 저장하는 인증서의 발급을 요청함
3. CA 기업은 CA 기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A 기업에게 이를 제공
4. A 기업은 클라이언트에게 암호화된 인증서를 제공
5. 브라우저는 CA 기업의 공개키를 미리 다운받아 갖고 있어, 암호화된 인증서를 복호화함
6. 암호화된 인증서를 복호화하여 얻은 A 기업의 공개키로 세션키를 공유

---



## 프록시 서버가 필요한 이유와 작동 과정

#### 프록시 (Proxy)

- 컴퓨터 네트워크에서 다른 서버 상의 자원을 찾는 클라이언트로부터 요청을 받아 **중계하는 서버**
- 클라이언트가 서버로부터 필요한 파일, 연결, 웹 페이지 등과 같은 자원을 프록시 서버에 요청하면 프록시 서버는 클라이언트와의 사이에서 대신 통신을 수행
- 프록시 서버에는 클라이언트로부터 원격에 요청된 자원들이 캐시되어 임시로 저장되어 있어 이같이 중계자 역할이 가능
- 자원 재요청 시 원격 서버에 접속할 필요 없이 프록시 서버 내의 정보를 제공받을 수 있으며, 따라서 데이터 전송 시간과 외부 트래픽이 줄어들고 서버 측의 네트워크 병목 현상 방지 가능

- 프록시 서버 측에서 위험이 예상되는 웹 컨텐츠 및 악성코드를 필터링 함으로써 **클라이언트 측의 보안 향상 가능**
- 보안 유지를 위해 내부 통신과 외부 데이터 접근(특정 사이트 접근 차단)을 통제하고 인터넷 이용률 통계를 수집하기 위해 프록시 서버를 사용하기도 함
  - 로그가 남기 때문에 분석에 용이
- 역기능으로는 사용자의 입장에서 자신의 웹 서핑 기록을 익명화하기 위해 익명 웹 프록시를 사용
  - 중계서버를 거쳐 넘어가기 때문에 자신의 IP 기록이 남지 않게 만듦



#### 프록시 서버 종류

- **포워드 프록시 (forward proxy)**
  - 프록시 서버가 클라이언트와 원격 서버 사이의 네트워크 상 어디에든 위치할 수 있음
  - 프록시 서버는 클라이언트가 알려주기 전에 목적지 서버의 주소를 알지 못함
- **리버스 프록시 (reverse proxy)**
  - 프록시 서버가 사설 네트워크 상의 서버들 바로 앞단의 프론트엔드에 위치하여 서버들을 제어하고 보호함
  - 리버스 프록시 서버는 클라이언트의 요청에 따라 자신의 뒷쪽(reverse)에 있는 적합한 서버에 데이터 요청을 전달하고 응답된 데이터를 클라이언트로 전달
  - 리버스 프록시 서버는 자신의 뒷쪽에 있는 실제 서버들에 대한 주소를 유지하고 있어야 함
  - 보안이나 암호화 or 뒷단의 서버들에 대한 요청을 로드밸런싱
- **오픈 프록시 (open proxy)**
  - 모든 인터넷 사용자가 액세스 할 수 있는 프록시 서버
  - 익명 공개 프록시
    - 사용자가 웹 브라우징을 하거나 다른 인터넷 서비스를 사용하는 동안 자신의 IP 주소를 숨길 수 있도록 해줌
  - IP 추적 방지 및 우회 접속 기능 가능



#### 프록시 서버의 사용목적

- 개인정보 보호

  - 프록시 서버 사용시 나의 IP가 아닌 프록시 서버의 IP가 보이게 됨

- 캐시 사용 - 속도 향상

  - 프록시 서버가 웹페이지를 가져올 때 자신의 DB에 최근 데이터를 저장 (캐시)
  - 가비지 컬렉션을 통해 캐시 상태 유지

- 로그 기록 관리

  - IP 로그 조사 가능
  - 방문 가능한 웹사이트 제한 가능

  => 회사에서 많이 사용함

- 방화벽
  - 프록시는 요청을 제어, 방화벽은 네트워크 패킷을 제어
- 접속 우회
  - 클라이언트의 IP를 숨기기 위해 여러 프록시 서버를 경유하는 기술 : Proxy Chaining
  - 클라이언트 -> 프락시 서버 1 -> 프락시 서버 2 -> 서버



#### 암호화 문제

- 프록시 서버는 데이터를 암호화(encryption) 하지는 않음
- 프록시 서버가 사용하는 네트워크는 기본적으로 공용망(Public Network)이기 때문에 장비만 갖춘다면 해커나 공공기관 ISP에서도 클라이언트가 보내는 데이터 탈취 가능
- 정보를 암호화 하려면 VPN을 사용하면 됨
- VPN (Virtual Private Network, 가상 사설 네트워크)
  - 서버와 클라이언트 간에 보안처리된 터널을 만들어 암호화된 데이터를 주고 받기 때문에 보안이 유지됨

