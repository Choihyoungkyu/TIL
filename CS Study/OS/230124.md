# 230124

#### 목차

1. Garbage Collection
2. 동기 vs 비동기
3. semaphore vs mutex
4. 함수 call vs 시스템 call
5. deadlock의 조건
6. 부동 소수점



## Garbage Collection

#### Garbage Collection

- JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스
- 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에 대해 관리하지 않아도 되어 개발에만 집중할 수 있는 장점
- Java, Python, JavaScript, Go 등 많은 프로그래밍 언어에서 가비지 컬렉션이 기본으로 내장됨
- 단점 
    1. 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘듦
    2. GC가 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생 (STW : Stop-The-World)

* STW : Major GC가 일어나면 Thread가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 멈추거나 버벅이는 현상이 일어나기 때문



#### Garbage Colletion 대상

- 도달성, 도달능력(Reachability)라는 개념을 적용하여 Garbage 판단
  -> Reachable : 객체가 참조되고 있는 상태
  -> Unreachable : 객체가 참조되고 있지 않은 상태 (GC의 대상이 됨)



#### Garbage Collection 청소 방식

- Mark And Sweep : 대상 객체 식별(Mark) 후 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행
- 루트로부터 해당 객체에 접근이 가능한지가 해제의 기준이 됨
  -> Mark 과정 : Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
  -> Sweep 과정 : 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거
  -> Compact 과정 : Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축



#### heap 메모리의 구조

JVM의 힙(heap) 영역은 동적으로 레퍼런스 데이터가 저장되는 공간으로서, 가비지 컬렉션에 대상이 되는 공간
Heap 영역의 2가지 전제 (Weak Generational Hypothesis)

1. 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
2. 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.
- 즉, 객체는 대부분 일회성되며, 메모리에 오랫동안 남아있는 경우는 드물다
- 이러한 특성 때문에 효율적인 메모리 관리를 위해, 객체의 생존기간에 따라 물리적인 Heap 영역을 나누게 되었고 Young과 Old 총 2가지 영역으로 설계하였다



#### Young 영역 (Young Generation)

- 새롭게 생성된 객체가 할당 (Allocation) 되는 영역
- 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 사라짐
- Young 영역에 대한 가비지 컬렉션을 Minor GC 라고 부른다.
- 더욱 효율적인 GC를 위해 Young 영역을 3가지 영역(Eden, survivor 0, survivor 1)으로 나눈다.



#### Old 영역 (Old Generation)

- Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생
- Old 영역에 대한 가비지 컬렉션을 Major GC 또는 Full GC라고 부른다.



#### Eden

- new를 통해 새로 생성된 객체가 위치
- 정기적인 쓰레기 수집 후 살아남은 객체들은 Survivor 영역으로 보냄



#### Survivor 0 / Survivor 1

- 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
- Survivor 영역에는 특별한 규칙이 있는데, Survivor 0 또는 Survivor 1 둘 중 하나는 꼭 비어있어햐 함



#### Minor GC 과정

- 모든 객체는 처음에는 Young Generation에 생성됨
- 상대적으로 크기가 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸림
1. 처음 생성된 객체는 Young Generation 영역의 일부인 Eden 영역에 위치
2. 객체가 계속 생성되어 Eden 영역이 꽉차게 되고 Minor GC가 실행
3. Mark 동작을 통해 reachable 객체를 탐색
4. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동
5. Eden 영역에서 사용되지 않는 객체(unreachable)의 메모리를 해제(sweep)
6. 살아남은 모든 객체들은 age값이 1씩 증가
7. 또다시 Eden 영역에 신규 객체들로 가득 차게 되면 다시한번 minor GC가 발행하고 mark 한다
8. marking 한 객체들을 비어있는 Survival 1으로 이동하고 sweep
9. 다시 살아남은 모든 객체들은 age가 1씩 증가
10. 계속 반복



#### Major GC 과정

- Survivor에서 age 임계값이 차게되어 이동한 데이터들
- 객체들이 계속 Promotion(Young -> Old)되어 Old 영역의 메모리가 부족해지면 발생
- 메모리 공간이 커서 속도가 느림
1. 객체의 age가 임계값에 도달하게 되면 Old Generation으로 이동 (Promotion)
2. 위의 과정이 반복되어 Old Generation 영역의 공간(메모리)이 부족하게 되면 Major GC 발생
3. Old 영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 한꺼번에 삭제 -> 오래 걸림 -> Stop-The-World



#### Garbage Collection Algorithms

1. **Serial GC**
- 서버의 CPU 코어가 1개일 때 사용하기 위해 개발된 가장 단순한 GC
- GC를 처리하는 쓰레드가 1개 (싱글 쓰레드) 여서 가장 stop-the-world 시간이 길다
- Minor GC에는 Mark-Sweep을 사용하고, Major GC에는 Mark-Sweep-Compact를 사용
- 보통 실무에서 사용하는 경우는 X (디바이스 성능이 안좋아서 CPU 코어가 1개인 경우에만 사용)



2. **Parallel GC**
- Java 8의 디폴트 GC
- Serial GC와 기본적인 알고리즘은 같지만, Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old 영역은 여전히 싱글 쓰레드)
- Serial GC에 비해 stop-the-word 시간 감소



3. **Parallel Old GC (Parallel Compacting Collector)**
- Young 영역 뿐만 아니라, Old 영역에서도 멀티 쓰레드로 GC 수행
- 새로운 가비지 컬렉션 청소 방식인 Mark-Summary-Compact 방식을 이용



4. **CMS GC (Concurrent Mark Sweep)**
- 어플리케이션의 쓰레드와 GC 쓰레드가 동시에 실행되어 stop-the-world 시간을 최대한 줄이기 위해 고안된 GC
- 단, GC 과정이 매우 복잡해짐
- GC 대상을 파악하는 과정이 복잡한 여러단계로 수행되기 때문에 다른 GC 대바 CPU 사용량이 높다
- 메모리 파편화 문제
- CMS GC는 Java9 버전부터 deprecated 되었고, 결국 Java14에서는 사용이 중지됨



5. **G1 GC (Garbage First)**
- CMS GC를 대체하기 위해 jdk 7 버전에서 최초로 release된 GC
- Java 9+ 버전의 디폴트 GC로 지정
- 4GB 이상의 힙 메모리, Stop The World 시간이 0.5초 정도로 필요한 상황에 사용 (Heap이 너무 작을 경우 미사용 권장)
- 기존의 GC 알고리즘에서는 Heap 영역을 물리적으로 고정된 Young / Old 영역으로 나누어 사용했지만, G1 GC는 아예 이러한 개념을 뒤엎는 Region이라는 개념을 새로 도입
- 전체 Heap 영역을 Region이라는 영역으로 체스같이 분할하여 상황에 따라 Eden, Survivor, Old 등 역할을 고정이 아닌 동적으로 부여
Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 원리



6. **Shenandoah GC**
- Java 12에 release
- 레드 햇에서 개발한 GC
- 기존 CMS가 가진 단편화, G1이 가진 pause의 이슈를 해결
- 강력한 Concurrency와 가벼운 GC 로직으로 heap 사이즈에 영향을 받지 않고 일정한 pause 시간 소요가 특징



7. **ZGC (Z Garbage Collector)**
- Java 15에 release
- 대량의 메모리(8MB ~ 16TB)를 low-latency로 잘 처리하기 위해 디자인 된 GC
- G1의 Region처럼, ZGC는 ZPage라는 영역을 사용하며, G1의 Region은 크기가 고정인데 비해, ZPage는 2mb 배수로 동적으로 운영됨
- ZGC가 내세우는 최대 장점 중 하나는 힙 크기가 증가하더라도 'Stop-The-World`의 시간이 절대 10ms를 넘지 않는다는 것

---



## 동기 vs 비동기

#### 동기 (synchronous)

- 사용자가 데이터를 서버에게 요청한다면 그 서버가 데이터 요청에 따른 응답을 사용자에게 다시 리턴해주기 전까지 사용자는 **다른 활동을 할 수 없으며 기다려야만합니다**.



#### 비동기 (asynchronous)

- 서버에게 데이터를 요청한 후 요청에 따른 응답을 계속 **기다리지 않아도되며** 다른 외부 활동을 수행하여도되고 서버에게 다른 요청사항을 보내도 상관없습니다



#### 동기 / 비동기 장단점

- 동기
  - 장점 : 설계가 매우 간단하고 직관적
  - 단점 : 결과가 주어질 때까지 아무것도 못하고 대기해야함
- 비동기
  - 장점 : 요청에 따른 결과가 반환되는 시간 동안 다른 작업을 수행할 수 있음 -> 효율적인 자원 사용 가능
  - 단점 : 동기식보다 설계가 복잡

---



## semaphore vs mutex

- 동기화 접근 방식 도구 : semaphore, mutex



#### Mutex

- 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 **하나**)
- 임계구역을 가진 스레드들의 실행시간(Running Time)이 서로 겹치지 않고 각각 단독으로 실행(상호배제, Mutual Exclution)되도록 하는 기술
- 한 프로세스에 의해 소유될 수 있는 **Key를 기반으로 한 상호배제 기법**으로 Key에 해당하는 어떤 객체(Object)가 있으며, **이 객체를 소유한 스레드/프로세스만이 공유자원에 접근** 가능
- 다중 프로세서들의 공유 리소스에 대한 접근을 조율하기 위해 **동기화(Synchronization) 또는 락(Lock)**을 사용함으로써 뮤텍스 객체를 두 스레드가 동시에 사용 불가

=> 상가 화장실이 1칸짜리이고 키가 하나 밖에 없을 때, 키가 없으면 사람이 있다는 뜻 (키 : Mutex)



#### Semaphore

- 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 **하나 이상**)
- 사용하고 있는 스레드/프로세스의 수를 **공통으로 관리하는 하나의 값**(세마포어)을 이용해 상호배제를 달성
- 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있으며, 각 프로세스는 세마포어의 값을 확인하고 변경 가능
- 자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용하고 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면, 재시도전에 일정시간 대기해야 함

=> 레스토랑의 화장실에는 여러 개의 칸이 있고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있다고 가정
==> 만약 당신이 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음 화장실로 입장해야 하며 나올 때 빈 칸의 개수를 하나 더해줘야함
===> 모든 칸에 사람이 들어갔을 경우 빈 칸의 개수는 0이 되며 이때 화장실에 들어가고자 하는 사람이 있다면 빈 칸의 개수가 1 혹은 양수로 바뀔 때까지 기다려야함
(화장실 : 공유자원, 사람 : 쓰레드/프로세스, 전광판 : Semaphore)



#### Mutex vs Semaphore

- **Mutex**는 동기화 대상이 오직 1개일 때 사용, **Semaphore**는 동기화 대상이 1개 이상일 때 사용
- **Mutex**는 자원을 소유할 수 있고, 책임을 가지는 반면, **Semaphore**는 자원 소유가 불가능
- **Mutex**는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제 가능. 반면 **Semaphore**는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제 가능
- **Semaphore**는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, **Mutex**는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.

---



## 함수 Call vs 시스템 Call

#### 시스템 콜

- OS의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스
- 보통 C, C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기에 고급 API를 통해 시스템 호출에 접근하게 하는 방법



#### 시스템 콜이 필요한 이유

- 우리가 일반적으로 사용하는 '응용 프로그램'은 유저레벨의 프로그램으로 기능 구현에 한계가 있으므로 **시스템 콜**을 통해 커널 모드로 전환한 후 작업을 수행할 권한이 생기도록 만든다.



#### 커널(kernel)

- 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용
- 이때 메모리에 상주하는 운영체제의 부분을 kernel(커널)이라고 함



#### CPU 모드

- **Mode bit**으로 구분
  - 0 : 커널 모드(kernel mode)
    - 운영체제(OS)가 CPU를 사용하는 모드
  - 1 : 사용자 모드(user mode)
    - 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O 등)에 접근 불가
    - 시스템 콜(System Call)을 사용해 커널 모드로 전환해야함



#### 시스템콜 종류

1. 프로세스 제어 (Process Control)
2. 파일 조작 (File Manipulation)
3. 장치 관리 (Device Manipulation)
4. 정보 유지 (Information Maintenance)
5. 통신 (Communication)
6. 보호 (Protection)



#### 함수 호출 vs 시스템 호출

- **함수 호출**은 사용자가 작성한 함수 및 라이브러리의 메서드 등을 호출하는 것이고, **시스템 호출**은 OS 내에 미리 정의되어 있는 함수를 호출하는 것

---



## 데드락(Deadlock, 교착 상태)

#### 데드락(Deadlock)

- 시스템 자원에 대한 요구가 뒤엉킨 상태
- 즉, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황



#### 데드락(Deadlock) 발생조건

1. 상호 배제
   - 한 번에 프로세스 하나만 해당 자원 사용이 가능해야 함
2. 점유 대기
   - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함
3. 비선점
   - 이미 할당된 자원을 강제로 빼앗을 수 없어야 함
4. 순환 대기
   - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 함



#### 데드락(Deadlock) 해결법

1. **예방 (Prevention)**
2. **회피(Avoidance)**
3. **탐지(Detection)**
4. **회복(Restore)**

---



## 부동 소수점 (Floating Point)

#### 부동 소수점

- 아주 작은 수와 아주 큰 수, 그리고 무한과 Nan을 표현하기 위해 도입된 타입
- 값이 커질수록 호차가 기하급수적으로 증가
- 실수 = 가수부 + 지수부 ===> ±(1.가수부)×2^(지수부-127)
- 장점 : 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현 가능
- 단점 : 실수의 표현은 항상 오차가 존재
  - 정수 계산은 정수 타입에 맡기고, 정밀 계산을 위해서라면 계산 전용 라이브러리 이용
  - 부동소수점을 사용해야만 한다면 정밀도가 높을수록 좋기 때문에 double(64bit) 사용하기
- **[ 0** **00000000** **00000000000000000000000** **]**
  - 앞 부분 (1 bit) : 부호를 결정. 0이면 양수, 1이면 음수
  - 중간 부분 (8 bit) : 지수를 표현(= 2의 곱을 표현)
    - 양수와 음수를 표현해야 하기 때문에 255 까지가 아니라 [-127 ~ 128] 까지 표현 가능
  - 뒷 부분 (23 bit) : 가수를 표현. 실질적인 숫자
    - ex) 123.456을 표현한다고 치면 가수는 123456

