# 2. 옵티마이저

---

> 사용자가 실행한 SQL을 해석하고, 데이터를 추출을 위한 실행계획을 수립하는 프로세스



## 옵티마이저의 종류

#### 오라클

- RBO : 초창기 버전부터 제공함
- CBO : v10g부터 기본적인 설정으로 적용되고 있음 -> 현재 모든 DBMS에서 주로 사용되는 옵티마이저 종류



#### RBO (Rule Based Optimizer)

- 기본적으로 **15개의 순위가 매겨진 규칙**이 있음
  - 이를 기초로 해서 실행계획을 수립함
- SQL에 대한 실행계획이 하나 이상일 경우엔, **순위가 높은 규칙**을 이용하게 됨
- 수립될 실행계획이 예측 가능하기 때문에 개발자가 **원하는 처리 경로로 유도하기가 쉬움**

| Rank | Access Path                                                  |
| :--: | ------------------------------------------------------------ |
|  1   | Rowid에 의한 1 row                                           |
|  2   | 클러스터 조인에 의한 1 row                                   |
|  3   | Unique나 Primary Key를 사용한 해시 클러스터 키에 의한 1 row  |
|  4   | Unique나 Primary Key에 의한 1 row                            |
|  5   | 클러스터 조인                                                |
|  6   | 해시 클러스터 키                                             |
|  7   | 클러스터 키                                                  |
|  8   | 결합 컬럼 (Composite) 인덱스                                 |
|  9   | 단일 컬럼 (Single) 인덱스                                    |
|  10  | 인덱스에 의한 유한 영역 검색 (Bounded range search on indexed columns) (ex. =, LIKE, BETWEEN, etc...) |
|  11  | 인덱스에 의한 무한 영역 검색 (Unbounded range search on indexed columns) (ex. <, >, etc...) |
|  12  | 소트 머지 (Sort Merge) 조인                                  |
|  13  | 인덱스로 구성된 컬럼의 최대 또는 최소 (MAX or MIN of indexed columns) |
|  14  | 인덱스로 구성된 컬럼으로 ORDER BY (ORDER BY on indexed columns) |
|  15  | 인덱스 없이 전체 테이블 스캔 (FTS : Full Table Scan)         |



#### CBO (Cost Based Optimizer)

- 대상 row들을 처리하는데 필요한 **자원 사용을 최소화**해서, 궁극적으로 **데이터를 빨리 처리**하는 데 목적이 있음
- CBO에 영향을 미치는 비용 산정 요소
  - 각종 통계 정보, Hint, 연산자, Index, Cluster, DBMS 버전, CPU/Memory 용량, Disk I/O 등과 같이 매우 다양함



#### CBO의 통계정보

- CBO의 성능을 최적의 상태로 유지시키기 위해서 테이블, 인덱스, 클러스터 등을 대상으로 통계 정보를 생성함
  - **정기적으로 ANALYZE 작업**을 하는 것이 가장 중요함!! (테이블과 데이터는 늘 변동이 있기 때문에)
- 이렇게 생성된 통계 정보는 옵티마이저가 가장 효율적인 실행계획을 수립하기 위해 **최소비용을 계산**할 때 중요하게 사용됨



#### ANALYZE 실행

```sql
ANALYZE TABLE EMP COMPUTE STATISTICS;
ANALYZE TABLE EMP ESTIMATE STATISTICS
									SAMPLE 10 PERCENT;
ANALYZE TABLE EMP ESTIMATE STATISTICS
									SAMPLE 5 ROWS;
```



#### DMBS_STATS Package (ORACLE)

```sql
DBMS_STATS.GATHER_TABLE_STATS('hr', 'EMP', NULL, 20, FALSE, 'FOR ALL COLUMNS', 4)

BMS_STATS.GATHER_TABLE_STATS('hr', 'EMP', NULL, NULL, FALSE, 'FOR ALL COLUMNS', 4)

DBMS_STATS.GATHER_SCHEMA_STATS('hr')

DBMS_STATS.GATHER_DATABASE_STATS
```

- 오라클에서는 ANALYZE에 대한 패키지를 제공함으로써 좀 더 간편하고 효율적으로 해당 작업을 수행할 수 있도록 도와주고 있음

  (알아만 두고 실제 사용할때마다 구글링 하는게 편할듯)



#### 옵티마이저의 레벨별 설정

- **Instance Level** : initSID.ora 파일을 이용해서 지정함

  ```sql
  OPTIMIZER_MODE = [RULE / CHOOSE / FIRST_ROWS / ALL_ROWS]
  ```

- **Session Level**

  ```sql
  SQL> ALTER SESSION SET OPTIMIZER_MODE = [RULE / CHOOSE / FIRST_ROWS / ALL_ROWS]
  ```

- **Statement Level**

  ```sql
  SQL> SELECT /*+ first_rows */
  				ename
  			 FROM emp;
  ```

- 아무리 DB 차원에서 설정해도 우선순위는 힌트가 젤 높음



#### RBO와 CBO의 실행계획 비교

```sql
SELECT E.ENAME, D.DNAME
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10;
```

```
				< Rule Based Optimizer >													< Cost Based Optimizer >

							SELECT	0																				SELECT	0
											|																								|
				NESTED LOOPS	1																	NESTED LOOPS	1
										/		\																						/		\
		NESTED LOOPS	2				5	DEPT														DEPT	2				4	EMP
								/		\																							|
					EMP	3				4	PK_DEPT														PK_DEPT	3
```

---



### 예제)

#### INDEX

- EC_TASK_PK : COURSE_CODE + TASK_NO
- EC_TASK_TERM_IDX00 : COURSE_CODE + TASK_NO + YEAR + COURSE_SQ_NO

#### 쿼리문

```sql
SELECT A.COURSE_CODE, A.TASK_NO, A.BAS_YN, A.UPDATE_DATE, B.YEAR, B.S_DATE, B.E_DATE
  FROM EC_TASK A, EC_TASK_TERM B
 WHERE A.COURSE_CODE 	= B.COURSE_CODE
   AND A.TASK_NO 			=	B.TASK_NO
   AND B.COURSE_CODE	= 36
   AND B.TASK_NO			= 1
   AND B.COURSE_SQ_NO	= 1;
```

- WHERE 절에 B에 대한 단건 정보들이 있음
- 하지만 B의 인덱스에는 YEAR 컬럼도 있기 때문에 단건 조회가 아니라 다건 조회가 될 수 있음
- A와 B의 조인 조건으로 쓰이는 컬럼들에 명확한 조건이 명시되어 있고, 해당 컬럼들이 A의 인덱스에 속함
- 따라서, 해당 조건들로 A 테이블에서는 단건 조회가 되므로 효율적임
- 쿼리 실행 순서
  - RBO : B 테이블 먼저 스캔
  - CBO : A 테이블 먼저 스캔

#### 효율적인 쿼리 설계

```sql
SELECT A.COURSE_CODE, A.TASK_NO, A.BAS_YN, A.UPDATE_DATE, B.YEAR, B.S_DATE, B.E_DATE
  FROM EC_TASK A, EC_TASK_TERM B
 WHERE A.COURSE_CODE 	= B.COURSE_CODE
   AND A.TASK_NO 			=	B.TASK_NO
   AND A.COURSE_CODE	= 36	--수정
   AND A.TASK_NO			= 1		--수정
   AND B.COURSE_SQ_NO	= 1;
```

- A 테이블에 대한 조건으로 바꾸면 RBO로 옵티마이저가 실행된다고 해도 A 테이블을 먼저 스캔하게 됨

---



## Summary

#### 1. 옵티마이저의 개념

- 사용자가 실행한 SQL을 해석하고, 데이터를 추출하기 위한 실행계획을 수립하는 프로세스



#### 2. 옵티마이저의 종류

- RBO (Rule Based Optimizer)
  - 규칙기준 옵티마이저는 인덱스 구조나 사용하는 연산자에 따라 부여되는 순위가 정해져 있음 (Rank Rule)
- CBO (Cost Based Optimizer)
  - 대상 Rows를 처리하는데 필요한 자원 사용을 최소화해서 데이터를 빨리 처리하는데 목적이 있음



#### 3. 옵티마이저의 레벨별 설정

- 데이터베이스 전체에 지정

  ```
  [initSID.ora를 이용해서 지정]
  OPTIMIZER_MODE = [RULE / CHOOSE / FIRST_ROWS / ALL_ROWS]
  ```

- 세션별로 지정

  ```
  SQL> ALTER SESSION SET OPTIMIZER_MODE = [RULE / CHOOSE / FIRST_ROWS / ALL_ROWS]
  ```

- 각 SQL별로 지정

  ```
  SQL> SELECT /*+ first_rows */
  				ename
  			 FROM emp;
  ```



#### 4. RBO와 CBO의 실행계획 비교

- 동일 SQL에 대해서 각 옵티마이저가 수립한 실행계획은 서로 다를 수 있음
- 이는 SQL의 퍼포먼스가 옵티마이저에 따라 다르다는 의미
- 옵티마이저의 종류에 따라 달라지는 DB성능의 차이점을 이해하는 것이 중요함