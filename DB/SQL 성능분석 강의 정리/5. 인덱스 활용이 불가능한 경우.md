# 5. 인덱스 활용이 불가능한 경우

---

## 1. 인덱스를 사용하지 말아야 하는 경우

- 조건에 의한 처리범위가 넓어짐으로 인해 **분포도가 나빠지는 경우**가 있는데, 이 경우 인덱스 스캔을 하는 것보다는 **FULL TABLE SCAN을 하는 것이 바람직함**

  -> FULL TABLE SCAN 시엔 한 번의 I/O 때마다 여러 개의 데이터 Blocks을 처리하기 때문에 I/O 횟수가 감소하게 됨

  ​    (INDEX SCAN은 한 번의 I/O로 한 개의 Block만 처리 가능)



## 2. 인덱스 사용이 불가능한 경우

1. **NOT 연산자 사용**

   ```sql
   SELECT * FROM EMP WHERE EMPNO != 7654; -- 해당 데이터 빼고 모든 데이터를 찾아야됨 -> 15% 이상 스캔
   ```

2. **IS NULL, IS NOT NULL 사용**

   ```sql
   SELECT * FROM EMP WHERE EMPNO IS NULL;			-- 인덱스에는 null이 없기 때문에 인덱스 사용 불가능
   
   SELECT * FROM EMP WHERE EMPNO IS NOT NULL;
   ```

3. **옵티마이저의 취사 선택**

   - 옵티마이저의 자의적 판단에 의해서 인덱스를 사용할 수도 있고 사용하지 않을 수도 있는데, 이것을 **취사 선택**이라고 함

   - Rule Base Optimizer(RBO) : 정해진 규칙 기준

   - Cost Base Optimizer(CBO) : 비용 기준

     ==> Optimizer의 자의적 판단으로 인한 **잘못된 선택을 강제로 제어**하기 위해 **Hint** 사용

4. **External suppressing** : 겉으로 드러난 변형

   - **컬럼 변형을 한 경우 인덱스 사용 불가**

   1. 불필요한 함수를 사용한 경우

      ```sql
      WHERE SUBSTR(ENAME, 1, 1) = 'M';	
      -- ENAME이 인덱스일지라도 해당 컬럼에 함수를 걸어 변형시켜서 인덱스 사용이 불가
      
      -- 인덱스 사용이 가능하도록 변경한 코드
      WHERE ENAME LIKE 'M%';
      ```

   2. 문자열 결합

      ```sql
      WHERE JOB|DEPTNO = 'MANAGER10'
      -- JOB과 DEPTNO를 결합시켜 만들면 인덱스 사용 불가
      
      -- 인덱스 사용이 가능하도록 변경한 코드
      WHERE JOB = 'MANAGER' AND DEPTNO = '10';
      ```

   3. DATE 변수의 가공

      ```sql
      WHERE TO_CHAR(hiredate, 'YYYYMMDD') = '20021016'
      -- hiredate에 변형을 주었기 때문에 인덱스 사용 불가
      
      -- 인덱스 사용이 가능하도록 변경한 코드
      WHERE hiredate BETWEEN TO_DATE('20021016', 'YYYYMMDD') AND TO_DATE('20021016', 'YYYYMMDD');
      ```

   4. 산술식의 적용

      ```sql
      WHERE SAL * 12 > 40000;
      
      -- 인덱스 사용이 가능하도록 변경한 코드
      WHERE SAL > 40000 / 12;
      ```

5. **Internal suppressing** : DB 내에서 스스로 존재하는 컬럼에 대한 변형

   - (VARCHAR2 or CHAR) to NUMBER

   - (VARCHAR2 or CHAR) to DATE

   1. 간단한 연산식

      ```sql
      comm + '500'
      ```

   2. 논리비교 연산식

      ```sql
      bonus > sal / '10'
      ```

   3. 함수 호출

      ```sql
      MOD(sal, '100')
      ```

   4. WHERE절 조건

      - 컬럼 변형이 아닌 경우 (숫자형 컬럼 = 문자 인 경우)

      ```sql
      WHERE hiredate = '2003-01-01';	
      -- hiredate는 DATE 타입이고 뒤의 문자는 문자열이지만 내부적으로 DATE 타입으로 변환되기 때문에
      -- 컬럼에 대한 변형이 아니므로 인덱스 사용이 가능함
      ```

      ```sql
      WHERE ROWID = 'AAAAaoAATAAAADAAA';
      -- ROWID가 number이기 때문에 뒤의 문자가 숫자로 변환되어서 해당 컬럼은 인덱스 사용 가능
      ```

      - 컬럼 변형인 경우 (문자형 컬럼 = 숫자 인 경우)

      ```sql
      WHERE TO_NUMBER(RESNO) = 1239495; -- FULL SCAN (인덱스 사용 X)
      ```



## 3. 옵티마이저에 의한 선택 절차

- 특정 테이블에 대해서 SQL의 주어진 조건으로 인해 사용될 수 있는 인덱스가 두 개 이상인 경우

  - 옵티마이저는 **조건에 가장 적절한 인덱스를 선택**해서 사용해야 함
  - 주어진 조건에 가장 적절한 인덱스를 선택하려 할 때, **일련의 절차에 따라 결정**함

- 옵티마이저의 인덱스 선택 시 판단 절차

  1. 주어진 조건에 대한 각 인덱스 별로 매칭률을 계산해서 **매칭률이 높은 것**을 우선적으로 선택

     ```
     							(WHERE절에서 1st 컬럼부터 연속된 컬럼에 대해 상수(값)를 '='로 비교하는 컬럼의 개수
     인덱스 매칭률 = ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
     																	인덱스를 구성하는 컬럼의 총 개수
     ```

  2. 인덱스 별 매칭률이 같을 경우에는 인덱스를 구성하는 **컬럼의 개수가 많은 것**을 우선적으로 선택함

  3. 인덱스 별 매칭률과 인덱스를 구성하는 컬럼의 개수가 같을 경우에는 **가장 최근에 생성된 것**을 우선적으로 선택

- 예시 1) 

  - 인덱스 변경 전
    - **IX1_SALES(부서 + 기준일자) -> 매칭률 2/2**
    - IX2_SALES(품목) -> 매칭률 1/1
  - 인덱스 변경 후
    - IX1_SALES(부서 + 기준일자 + 순번) -> 매칭률 2/3
    - **IX2_SALES(품목) -> 매칭률 1/1**

  ```sql
  SELECT *
    FROM SALES
   WHERE 부서 	 = '843'
     AND 기준일자 = '970518'
     AND 품목 	 = 'B023';
  ```

- 예시 2) RBO와 CBO가 선택한 인덱스의 차이

  ```sql
  [인덱스 현황]
  EC_COURSE_SQ_PK			: COURSE_CODE + YEAR + COURSE_SQ_NO	-> 매칭률 2/3
  EC_COURSE_SQ_IDX_01	: YEAR (Non Unique)									-> 매칭률 1/1
  
  SELECT MIN(COURSE_SQ_NO)	AS MIN_SQ,
  			 MAX(COURSE_SQ_NO)	AS MAX_SQ
    FROM EQ_COURSE_SQ
   WHERE COURSE_CODE = 1960
     AND YEAR = '2002';
  ```

  - RBO : 매칭률이 높은 EC_COURSE_SQ_PK 선택
  - CBO : WHERE 절에서 두 개의 범위제한으로 더 효율적인 탐색을 하는 EC_COURSE_SQ_IDX_01을 선택

---

## 예제)

#### 인덱스

- EC_APPLY_PK : COURESE_CODE + YEAR + COURSE_SQ_NO + MEMBER_TYPE + MEMBER_ID



#### 쿼리문

```sql
SELECT /*+ INDEX(A EC_APPLY_PK) NO_USE_HASH_AGGREGATION */
			 COURESE_CODE,
			 NVL(SUM(DECODE(YEAR, '1999', 'DEPOSIT_AMOUNT')), 0)	Y1999,
			 NVL(SUM(DECODE(YEAR, '2000', 'DEPOSIT_AMOUNT')), 0)	Y2000,
			 NVL(SUM(DECODE(YEAR, '2001', 'DEPOSIT_AMOUNT')), 0)	Y2001,
			 NVL(SUM(DECODE(YEAR, '2002', 'DEPOSIT_AMOUNT')), 0)	Y2002
  FROM EC_APPLY A
 WHERE COURSE_CODE < 1000
   AND YEAR BETWEEN '1999' AND '2002'
GROUP BY COURESE_CODE;
```

```
call		count				cpu		elapsed			disk		query		current		rows
------- ----- --------- --------- -------- -------- --------- ------
Parse				1			 0.00			 0.00				 0				0					0			 0
Execute			1			 0.00			 0.00				 0				0					0			 0
Fetch			 39			12.35			12.34		 78459	 128569					0		 561
------- ----- --------- --------- -------- -------- --------- ------
total			 41			12.35			12.34		 78459	 128569					0		 561

Rows		Execution Plan
-------	------------------------------------------------------------
			0 SELECT STATEMENT MODE: ALL_ROWS
		561	 SORT (GROUP BY NOSORT)
 138883	  TABLE ACCESS MODE: ANALYZED (BY INDEX ROWID) OF 'EC_APPLY' (TABLE)
 138883	   INDEX MODE: ANALYZED (RANGE SCAN) OF 'EC_APPLY_PK' (INDEX (UNIQUE))
```

- 총 데이터 520,000건 중 138,883건을 스캔하고 있고 이는 15%가 넘으므로 인덱스를 사용하지 않아야 함
- 138,000건을 줄이고자 미리 GROUP BY를 사용해 데이터 건수를 줄여야 함



#### 변경한 쿼리문

```sql
SELECT /*+ INDEX(A EC_APPLY_PK) NO_USE_HASH_AGGREGATION */
			 COURESE_CODE,
			 NVL(SUM(DECODE(YEAR, '1999', 'DEPOSIT_AMOUNT')), 0)	Y1999,
			 NVL(SUM(DECODE(YEAR, '2000', 'DEPOSIT_AMOUNT')), 0)	Y2000,
			 NVL(SUM(DECODE(YEAR, '2001', 'DEPOSIT_AMOUNT')), 0)	Y2001,
			 NVL(SUM(DECODE(YEAR, '2002', 'DEPOSIT_AMOUNT')), 0)	Y2002
  FROM (
  			SELECT /*+ FULL(EC_APPLY) */	-- 인덱스 사용 X
    					 COURSE_CODE,
    					 YEAR,
    					 SUM(DEPOSIT_AMOUNT) DEPOSIT_AMOUNT
    		  FROM EC_APPLY
    		 WHERE COURSE_CODE < 1000
    			 AND YEAR BETWEEN '1999' AND '2002'
    		GROUP BY COURSE_CODE, YEAR
  ) A		-- 해당 서브쿼리를 INLINE VIEW라고 함 -> 데이터 수를 줄일 수 있음
GROUP BY COURESE_CODE;
```

- 기존 GROUP BY는 Sorting이 기본이었지만, 오라클 10g 버전부터는 Hashing으로 바뀜
- NO_USE_HASH_AGGREGATION 힌트로 Sorting으로 바꿔줌 (왜????)

```
call		count				cpu		elapsed			disk		query		current		rows
------- ----- --------- --------- -------- -------- --------- ------
Parse				1			 0.00			 0.01				 0				0					0			 0
Execute			1			 0.00			 0.01				 0				0					3			 0
Fetch			 39			 0.02			 1.34		     0	      0					0		 561
------- ----- --------- --------- -------- -------- --------- ------
total			 41			 0.02			 1.36		     0	      0					3		 561

Rows		Execution Plan
-------	------------------------------------------------------------
			0 SELECT STATEMENT MODE: ALL_ROWS
		561	 SORT (GROUP BY)
		894   VIEW
 		894		 HASH (GROUP BY)
 138883	    TABLE ACCESS MODE: ANALYZED (FULL) OF 'EC_APPLY' (TABLE)
```

---

## SUMMARY

#### 1. 인덱스를 사용하지 말아야 하는 경우

6블록 이상의 데이터를 가진 테이블에 대해서, 쿼리로 처리할 데이터가 전체 데이터 중 15% 이상을 초과할 경우엔 인덱스를 사용하지 않는 것이 매우 좋은 성능을 냄



#### 2. 인덱스 사용이 불가능한 경우

- NOT 연산자와 비교
- IS NULL, IS NOT NULL
- 옵티마이저에 의한 취사선택
- 인덱스 컬럼의 변형(External / Internal Suppressing)



#### 3. 옵티마이저에 의한 선택 절차

1. 주어진 조건에 대한 각 인덱스 별로 매칭률을 계산해서 매칭률이 높은 것을 우선적으로 선택

   ```
   							(WHERE절에서 1st 컬럼부터 연속된 컬럼에 대해 상수(값)를 '='로 비교하는 컬럼의 개수
   인덱스 매칭률 = ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
   																	인덱스를 구성하는 컬럼의 총 개수
   ```

2. 인덱스 별 매칭률이 같을 경우에는 인덱스를 구성하는 컬럼의 개수가 많은 것을 우선적으로 선택

3. 인덱스 별 매칭률과 인덱스를 구성하는 컬럼의 개수가 같을 경우에는 가장 최근에 생성된 것을 우선적으로 선택





