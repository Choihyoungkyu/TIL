# 8. 조인조건이 없는 조인

---

## 1. CARTESIAN PRODUCT의 개념

- Cartesian Product가 발생하는 경우

  1. WHERE절이 없는 조인 수행
  2. 조인을 위한 조건 없이 조인 수행

- '데이터 복제'라는 개념을 활용하기 위해 사용하지만, 잘못 사용하게 되면 오히려 데이터를 부풀리는 원인이 되기 때문에 퍼포먼스를 오히려 나쁘게 할 수도 있음

- 예시) A : column1 - [10, 20, 30]

  ​	B : column2 -  ['A', 'B']

  ```sql
  SELECT * FROM A, B
  ```

| column1 | column2 |
| :-----: | :-----: |
|   10    |   'A'   |
|   20    |   'A'   |
|   30    |   'A'   |
|   10    |   'B'   |
|   20    |   'B'   |
|   30    |   'B'   |



## 2. 자주 사용하는 방법

- COPY_T, IMSI_T, DUMMY_T와 같은 temporary Table을 활용함 (네이밍룰 이슈로 현업에서는 무리)

- DUAL을 사용함

- 타 SQL에서 사용하고 있는 Table 활용 및 ROWNUM을 사용함

  => 주로 MASTER 성 테이블을 사용함



## 3. CARTESIAN PRODUCT 적용 예제

#### 예제1)

```sql
SELECT '직군별' AS class, job, COUNT(*) AS cnt
  FROM emp
GROUP BY job
UNION ALL
SELECT '부서별' AS class, TO_CHAR(deptno), COUNT(*) AS cnt
  FROM emp
GROUP BY deptno
UNION ALL
SELECT '총인원' AS class, null, COUNT(*) AS cnt
  FROM emp
```

- WHERE절 없이 emp 테이블을 3번 FULL TABLE SCAN 함 -> 튜닝 포인트임
- 수정한 쿼리

```sql
SELECT DECODE(rn, 1, '직군별', 2, '부서별', '총인원') AS class,
			 DECODE(rn, 1, job, 2, deptno),
			 SUM(cnt)
	FROM (
    		SELECT job, deptno, COUNT(*) AS cnt
       		FROM emp
        GROUP BY job, deptno
  		 ),
       (
         SELECT ROWNUM AS rn
        	 FROM (
             		 SELECT LEVEL FROM dual
                	CONNECT BY ROWNUM <= 3
                )
       )
GROUP BY rn,
				 DECODE(rn, 1, '직군별', 2, '부서별', '총인원'),
			 	 DECODE(rn, 1, job, 2, deptno);
```

- emp 테이블을 1번만 조회하기 때문에 성능 향상



#### 예제2) Transpose

기존 테이블

| ENAME |  Q1  |  Q2  |  Q3  |  Q4  |
| :---: | :--: | :--: | :--: | :--: |
|  JSC  | 1000 | 2000 | 3000 | 4000 |
|  JYJ  | 1500 | 2500 | 3500 | 4500 |

변경 테이블

| ENAME | QTR  | SAL  |
| :---: | :--: | :--: |
|  JSC  |  1   | 1000 |
|  JSC  |  2   | 2000 |
|  JSC  |  3   | 3000 |
|  JSC  |  4   | 4000 |
|  JYJ  |  1   | 1500 |
|  JYJ  |  2   | 2500 |
|  JYJ  |  3   | 3500 |
|  JYJ  |  4   | 4500 |

```sql
SELECT a.ename, b.qtr, DECODE(b.qtr, 1, a.q1, 2, a.q2, 3, a.q3, 4, a.q4) AS sl
  FROM (SELECT ename, q1, q2, q3, q4, ROWNUM
       		FROM emp_sal) a,
       (SELECT ROWNUM AS qtr
       		FROM (SELECT LEVEL FROM DUAL
               	CONNECT BY ROWNUM <= 4)) b
ORDER BY 1, 2;
```

- Oracle 11g 버전 부터는 위 예제를 `UNPIVOT` 함수를 통해서 수행 가능

```sql
WITH mytab AS (
	SELECT ename, q1, q2, q3, q4
    FROM emp_sal
)

SELECT ename, grp AS qtr, no
  FROM mytab
UNPIVOT (no FOR grp IN (q1 AS 1,
                        q2 AS 2,
                        q3 AS 3,
                        q4 AS 4))
ORDER BY ename;
```



#### 예제3) 1년치 달력 만들기

| EC_DAY (일자관리 테이블) |
| :----------------------: |
|  DAY /* 일자(01~31) */   |

```sql
SELECT ymd
	FROM (SELECT '2017'||a.day||b.day AS ymd,
       				 TO_CHAR(LAST_DAY(TO_CHAR('2017'||a.day, 'YYYYMM')), 'YYYYMMDD') AS eday
       		FROM ec_day b, ec_day a
         WHERE a.day <= '12'
       )
 WHERE ymd <= eday;
```

- ymd : 1~12월 전부 31일까지로 계산
- eday : 1~12월 각각의 마지막 날을 계산
- WHERE절에서 각 달의 마지막 날까지의 값만 남기면 끝

---

## SUMMARY

#### 1. CARTESIAN PRODUCT

- 곱집합
- 특정 테이블의 데이터를 필요한 만큼 복사(copy)하기 위한 방법
- CARTESIAN PRODUCT가 발생되는 경우
  - WHERE절이 없는 조인을 수행할 경우
  - 조인을 위한 조건 없이 조인을 수행할 경우



#### 2. Cartesian product시 자주 사용하는 테이블

- Cartesian product 만을 위한 전용 테이블을 생성해서 사용
- 이미 생성되어 있는 정규 테이블을 사용
- DUAL과 같은 dummy 테이블 사용



#### 3. CARTESIAN PRODUCT 적용 예제

- UNION으로 연결된 각각의 SQL이 읽고 있는 데이터가 전부 같을 경우, 데이터 복제와 같은 개념 활용을 위해 사용
- 데이터 구조 변환을 통해 사용자가 요청한 구조대로 데이터를 조회할 때 사용
- SQL문으로 일년치 날짜를 만들 때 사용



