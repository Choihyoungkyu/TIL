# 9. SUBQUERY와 함수의 활요

---

## 1. SUBQUERY의 종류

![SUBQUERY 종류](../Photos/SUBQUERY 종류.png)



## 2. NESTED SUBQUERY

- Main Query보다 Sub Query가 먼저 수행돼서 성능 향상이 될 때 사용
- 서브쿼리의 값과 비교하는 컬럼이 Main Query Table의 인덱스이고, 해당 연산자가 인덱스를 사용할 수 있어야 Sub Query가 먼저 실행됨

```sql
SELECT empno, ename
  FROM emp
 WHERE deptno = (SELECT deptno
                	 FROM dept
                	WHERE dname = 'SALES');
```



## 3. CORREALATED SUBQUERY

![CORREALATED SUBQUERY](../Photos/CORREALATED SUBQUERY.png)

- Main Query에서 하나씩 읽을때마다 Sub Query를 수행함

```sql
SELECT empno, ename
  FROM emp
 WHERE EXISTS (SELECT 'X' FROM dept
                	WHERE dept.deptno = emp.deptno	-- Main Query에서 값을 읽어와야 수행할 수 있음
               			AND dept.dname = 'SALES');
```



## 4. SCALAR SUBQUERY

- 하나의 데이터와 하나의 컬럼을 리턴하는 함수처럼 동작
  - Zero Result	=>	NULL Expression
  - One Row    	=>	Okay!!
  - Two or More       =>	Error Ora-1427

```sql
SELECT e.ename,
			 (SELECT d.dname
       		FROM dept d
       	 WHERE d.deptno = e.deptno) AS dname		-- Main Query에서 값을 읽어와야 수행할 수 있음
	FROM emp e;
```



## 5. ROLLUP() & CUBE()

- GROUP BY **YEAR, REGION**

  |          |             |  REGION  |          |
  | :------: | :---------: | :------: | :------: |
  | **YEAR** | **CENTRAL** | **EAST** | **WEST** |
  |   1995   |     100     |   200    |   200    |
  |   1996   |             |          |   200    |

- GROUP BY **ROLLUP(YEAR, REGION)** : 소계

  |          |             |  REGION  |          |         |
  | :------: | :---------: | :------: | :------: | :-----: |
  | **YEAR** | **CENTRAL** | **EAST** | **WEST** | **TOT** |
  |   1995   |     100     |   200    |   200    |   500   |
  |   1996   |             |          |   200    |   200   |
  |          |             |          |          |   700   |

- GROUP BY **CUBE(YEAR, REGION)** : 소계, 합계

  |          |             |  REGION  |          |         |
  | :------: | :---------: | :------: | :------: | :-----: |
  | **YEAR** | **CENTRAL** | **EAST** | **WEST** | **TOT** |
  |   1995   |     100     |   200    |   200    |   500   |
  |   1996   |             |          |   200    |   200   |
  | **TOT**  |     100     |   200    |   400    |   700   |



## 6. GROUPING SETS()

- GROUPING SETS으로 ROLLUP 구현

```SQL
SELECT d.dname, e.job,
			 COUNT(*) AS "Empl Cnt",
			 SUM(e.sal) AS "Tot Sal"
	FROM dept d, emp e
 WHERE d.deptno = e.deptno
GROUP BY GROUPING SETS((d.dname, e.job),
                       (d.dname),
                       ())
ORDER BY 1, 2;
```

- GROUPING SETS으로 CUBE 구현

```sql
SELECT d.dname, e.job,
			 COUNT(*) AS "Empl Cnt",
			 SUM(e.sal) AS "Tot Sal"
	FROM dept d, emp e
 WHERE d.deptno = e.deptno
GROUP BY GROUPING SETS((d.dname, e.job),
                       (d.dname),
                       (e.job),
                       ())
ORDER BY 1, 2;
```



## 7. ANALYTICAL FUNCTIONS

- SYNTAX

  ```sql
  SELECT Analytic_Function (arguments) OVER
  			([Partition By 컬럼] [Order By 절] [Windowing 절])
    FROM 테이블명 ... WHERE ...;
  ```

  | Arguments           | 함수에 따라 0~3개의 인자가 지정됨                  |
  | ------------------- | -------------------------------------------------- |
  | **Partition By 절** | 전체 집합을 기준에 의해 소그룹으로 나눔            |
  | **Order By 절**     | 어떤 항목에 대한 정렬 기준을 기술함                |
  | **Windowing 절**    | 함수에 의해서 제어하고자 하는 데이터 범위를 정의함 |

  

