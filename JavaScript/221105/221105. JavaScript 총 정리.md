# 221105. JavaScript 총 정리



## JavaScript의 역사

#### jQuery 등의 라이브러리 등장

- jQuery : 중간에 하나의 레이어를 두고 코딩하는 것
  - jQuery 문법에 맞춰 작성하면 브라우저별 엔진에 맞는 스크립트 변환은 jQuery가 알아서 변환



#### 2015, ECMAScript6 (ES6) 표준안 제정

- 모든 웹 브라우저가 표준안을 따름 -> 더 이상 jQuery 등의 라이브러리를 사용할 필요가 없어짐



#### Vanilla JavaScript

- 웹 브라우저에서 바로 실행할 수 있는 JavaScript 문법

---



## JavaScript 문법

#### 식별자(identifier)

- 변수를 구분할 수 있는 변수명
- 문자, 달러($) 혹은 밑줄(_)로 시작
- 대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작



#### 식별자 정의와 특징

- 카멜 케이스(**camelCase, lower-camel-case**)
  - 변수, 객체, 함수에 사용
- 파스칼 케이스(**PascalCase, upper-camel-case**)
  - 클래스, 생성자에 사용
- 대문자 스네이크 케이스(**SNAKE_CASE**)
  - 상수(constants)에 사용
  - 상수 : 개발자의 의도와 상관없이 변경될 가능성이 없는 값을 의미



#### 변수 선언 키워드

1. **let**
   - 블록 스코프 지역 변수를 선언 (추가로 동시에 값을 초기화)
   - **재할당 가능 & 재선언 불가능**
   - 블록 스코프
2. **const**
   - 블록 스코프 읽기 전용 상수를 선언 (추가로 동시에 값을 초기화)
   - 선언 시 반드시 초기값을 설정 해야 하며, 이후 값 변경이 불가능
   - **재할당 불가능 & 재선언 불가능**
   - 블록 스코프
3. **var**
   - 변수를 선언 (추가로 동시에 값을 초기화)
   - ES6 등장 이후 사용 X
     - **"호이스팅"** 되는 특성으로 인해 예기치 못한 문제 발생 가능성이 있기 때문
   - 함수 스코프



#### [참고] 호이스팅 (hoisting)

- 변수를 선언 이전에 참조할 수 있는 현상
- var로 선언된 변수는 선언 이전에 참조할 수 있으며, 변수 선언 이전의 위치에서 접근 시 undefined를 반환

- let, const는 호이스팅이 일어나면 에러 발생



#### 데이터 타입

- **원시 타입(Primitive type)**

  - Number

    - NaN (Not-A-Number)

  - String

    - Quote를 사용하면 escape sequence 사용 가능 (\n)
    - **Template Literal** (``)사용 시 줄 바꿈 or 변수 삽입 가능(${expression}), escape sequence 사용 불가 (=f-string)

  - Boolean

    | 데이터 타입 |   false    |       true       |
    | :---------: | :--------: | :--------------: |
    |  undefined  | 항상 false |        X         |
    |    null     | 항상 false |        X         |
    |   Number    | 0, -0, NaN | 나머지 모든 경우 |
    |   String    | 빈 문자열  | 나머지 모든 경우 |
    |   Object    |     X      |    항상 true     |

    

  - undefined

    - 직접 값을 할당하지 않으면 **자동으로 할당**됨
    - `typeof null            // "object"`

  - null

    - 변수의 값이 없음을 **의도적으로 표현**
    - `typeof undefined       // "undefined"`

  - Symbol

- **참조 타입(Reference type)**

  - Objects
    - Array
    - Function



#### 연산자

- 동등 연산자 (==)
  - 두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환
  - **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교
- 일치 연산자 (===)
  - 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환
  - 엄격한 비교가 이루어지며 **암묵적 타입 변환이 발생하지 않음**

- 삼항 연산자

  - 3개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자
  - 가장 앞의 조건식이 참이면 :(콜론) 앞의 값이 반환, 그 반대일 경우 : 뒤의 값이 반환

  ```js
  true ? 1 : 2		// 1
  false ? 1 : 2		// 2
  const result = Math.PI > 4 ? 'Yep' : 'Nope'
  console.log(result)	// Nope
  ```

  



#### 조건문

- **if statement**

  ```js
  const name = 'manager'
  if (name === 'admin') {
    console.log('관리자')
  } else if (name === 'manager') {
    console.log('매니저')
  } else {
    console.log('알바')
  }
  ```

- **switch statement**

  ```js
  switch(expression) {
    case 'first value': {
      // do something
      break
    }
    case 'second value': {
      // do something
      break
    }
    default: {
      // do something
    }
  }
  ```

  - 위에서부터 차례대로 실행되며 break가 걸리기 전까지의 모든 코드들을 실행



#### 반복문

- **while**

- **for**

- **for ... in**

  - 객체(object)의 속성을 순회할 때 사용
  - 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장 X
  - "속성 이름"을 통해 반복

  ```js
  const fruits = { a: 'apple', b: 'banana' }
  for (const key in fruits) {
    console.log(key)			// a, b
    console.log(fruits[key])	// apple, banana
  }
  ```

- **for ... of**

  - 반복 가능한 객체를 순회할 때 사용
  - 반복 가능한(iterable) 객체의 종류 : Array, Set, String 등
  - "속성 값"을 통해 반복

  ```js
  const numbers = [0, 1, 2, 3]
  for (const number of numbers) {
    console.log(number)		// 0, 1, 2, 3
  }
  ```

  

#### 조건문과 반복문 정리

|   키워드   |  종류  |     연관 키워드      |   스코프    |
| :--------: | :----: | :------------------: | :---------: |
|     if     | 조건문 |          -           | 블록 스코프 |
|   switch   | 조건문 | case, break, default | 블록 스코프 |
|   while    | 반복문 |   break, continue    | 블록 스코프 |
|    for     | 반복문 |   break, continue    | 블록 스코프 |
| for ... in | 반복문 |      객체 순회       | 블록 스코프 |
| for ... of | 반복문 |    Iterable 순회     | 블록 스코프 |

---



## 함수

#### 함수 선언식 (Function declaration)

- 익명함수 불가

- 호이스팅 발생

```js
function add(num1, num2) {
  return num1 + num2
}
```



#### 함수 표현식 (Function expression)

- 함수의 이름을 생략한 익명 함수로 정의 가능
- 호이스팅 X

```js
const sub = function (num1, num2) {
  return num1 - num2
}
```



#### 매개변수와 인자의 개수 불일치 허용

```js
const threeArgs = function (arg1, arg2, arg3) {
  return [arg1, arg2, arg3]
}
threeArgs()			// [undefined, undefined, undefined]
threeArgs(1)		// [1, undefined, undefined]
```



#### Spread syntax

- 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 배열의 경우는 요소, 함수의 경우는 인자로 확장 가능

  1. 배열과의 사용 (배열 복사)

     ```js
     let part1 = [1, 2, 3]
     let part2 = [4, 5, ...part1, 6]
     // [4, 5, 1, 2, 3, 6]
     ```

  2. 함수와의 사용 (Rest parameters)

     ```js
     const restOpr = function (arg1, arg2, ...restArgs) {
       return [arg1, arg2, restArgs]
     }
     restArgs(1, 2, 3, 4, 5)		// [1, 2, [3, 4, 5]]
     restArgs(1, 2)				// [1, 2, []]
     ```



#### Arrow Function

- 함수를 비교적 간결하게 정의할 수 있는 문법
- 화살표 함수는 항상 익명 함수 (= 함수 표현식에서만 사용 가능)

```js
const arrow1 = function (name) {
  return `hello, ${name}`
}

// 1. function 키워드 삭제
const arrow2 = (name) => { return `hello, ${name}`}

// 2. 인자가 1개일 경우에만 () 생략 가능
const arrow3 = name => { return `hello, ${name}` }

// 3. 함수 바디가 return을 포함한 표현식 1개일 경우에 {} & return 삭제 가능
const arrow4 = name => `hello, ${name}`
```

```js
// 1. 인자가 없다면? () or _ 로 표시 가능
let noArgs = () => 'No args'
noArgs = _ => 'No args'

// 2-1. object를 return 한다면
let returnObject = () => { return { key: 'value'} }		// return을 명시적으로 적어준다

// 2-2. return을 적지 않으려면 괄호를 붙여야 함
returnObject = () => ({ key: 'value' })
```



#### 즉시 실행 함수 (IIFE, Immediately Invoked Function Expression)

- 선언과 동시에 실행되는 함수
- 함수의 선언 끝에 '( )'를 추가하여 선언되자 마자 실행하는 형태

```js
(function(num) { return num ** 3 })(2)		// 8
(num => num ** 3)(2)						// 8
```

---



## Array와 Object

#### 배열 (Array)

- 키와 속성들을 담고 있는 참조 타입의 객체
- 순서를 보장하는 특징
- 배열의 길이는 `array.length` 형태로 접근 가능
  - (참고) 배열의 마지막 원소는 (array.length - 1)로 접근



#### 배열 메서드 기초

|     메서드      |                         설명                         |           비고           |
| :-------------: | :--------------------------------------------------: | :----------------------: |
|     reverse     |     **원본 배열**의 요소들의 순서를 반대로 정렬      |                          |
|   push & pop    |    배열의 **가장 뒤에** 요소를 **추가 또는 제거**    |                          |
| unshift & shift |    배열의 **가장 앞에** 요소를 **추가 또는 제거**    |                          |
|    includes     | 배열에 특정 값이 존재하는지 판별 후 **참/거짓 반환** |                          |
|     indexOf     | 배열에 특정 값이 존재하는지 판별 후 **인덱스 반환**  | 요소가 없을 경우 -1 반환 |
|      join       |    배열의 **모든 요소를 구분자를 이용하여 연결**     | 구분자 생략 시 쉼표 기준 |



#### 배열 메서드 심화

- 배열을 순회하며 특정 로직을 수행하는 메서드
- 메서드 호출 시 인자로 **callback 함수**를 받는 것이 특징
  - callback 함수 : 어떤 함수의 내부에서 실행될 목적으로 인자로 넘겨받는 함수

| 메서드  |                             설명                             |     비고     |
| :-----: | :----------------------------------------------------------: | :----------: |
| forEach |        배열의 각 요소에 대해 콜백 함수를 한 번씩 실행        | 반환 값 없음 |
|   map   | **콜백 함수의 반환 값**을 요소로 하는 **새로운 배열을 반환** |              |
| filter  | **콜백 함수의 반환 값이 참인 요소들만** 모아서 **새로운 배열을 반환** |              |
| reduce  |  **콜백 함수의 반환 값들을 하나의 값(acc)에 누적 후 반환**   |              |
|  find   |      콜백 함수의 **반환 값이 참이면 해당 요소를 반환**       |              |
|  some   |  배열의 **요소 중 하나라도 판별 함수를 통과하면 참을 반환**  |              |
|  every  |    배열의 **모든 요소가 판별 함수를 통과하면 참을 반환**     |              |



#### 배열 순회 비교

|    방식    |                             특징                             |             비고             |
| :--------: | :----------------------------------------------------------: | :--------------------------: |
|  for loop  | - 모든 브라우저 환경에서 지원<br />- 인덱스를 활용하여 배열의 요소에 접근<br />- break, continue 사용 가능 |                              |
| for ... of | - 일부 오래된 브라우저 환경에서 지원 X<br />- 인덱스 없이 배열의 요소에 바로 접근 가능<br />- break, continue 사용 가능 |                              |
|  forEach   | - 대부분의 브라우저 환경에서 지원<br />- break, continue 사용 불가능 | Airbnb Style Guide 권장 방식 |



#### 객체 (Object)

- 객체는 속성(property)의 집합이며, 중괄호 내부에 key와 value의 쌍으로 표현
- **key**
  - 문자열 타입만 가능
  - key 이름에 띄어쓰기 등의 구분자가 있으면 따옴표로 묶어서 표현
- **value**
  - 모든 타입(함수 포함) 가능
- 객체 요소 접근
  - 점(.) or 대괄호([])로 가능
  - key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능



#### 객체 관련 ES6 문법

1. 속성명 축약
   - 객체를 정의할 때 key와 할당하는 변수의 이름이 같으면 축약 가능
2. 메서드명 축약
   - 메서드 선언 시 function 키워드 생략 가능
3. 계산된 속성 (computed property name)
   - 객체를 정의할 때 key의 이름을 표현식을 이용하여 동적으로 생성 가능
4. 구조 분해 할당 (destructing assignment)
   - 배열 또는 객체를 분해하여 속성을 변수에 쉽게 할당할 수 있는 문법
5. Spread syntax
   - 배열과 마찬가지로 전개구문을 사용해 객체 내부에서 객체 전개 가능
   - 얕은 복사에 활용 가능



#### JSON (JavaScript Object Notation)

- Key - Value 형태로 이루어진 자료 표기법
- JavaScript의 Object와 유사한 구조를 가지고 있지만 Object는 그 자체로 타입이고, JSON은 형식이 있는 "문자열"
- **즉, JSON을 Object로 사용하기 위해서는 변환 작업이 필요**

```js
const jsObject = {
  coffee: 'Americano',
  iceCream: 'Cookie and cream',
}

// Object -> JSON
const objToJson = JSON.stringify(jsObject)

console.log(objToJson)		// {"coffee":"Americano","iceCream":"Cookie and cream"}
console.log(typeof objToJson)	// string

// JSON -> Object
const jsonToObj = JSON.parse(objToJson)

console.log(jsonToObj)		// {coffee: 'Americano', iceCream: 'Cooke and cream'}
console.log(typeof jsonToObj)	// object
```



#### [참고] 배열은 객체다

```js
Object.getOwnPropertyDescriptors([1, 2])

/*
{
  '0': { value: 1, writable: true, enumerable: true, configurable: true },
  '1': { value: 2, writable: true, enumerable: true, configurable: true },
  length: {value: 2, writable: true, enumerable: false, configurable: false}
}
*/
```

---



## DOM

#### 웹 페이지에서의 JavaScript

- JavaScript는 프로그래밍 언어로서의 역할도 가능하지만 클라이언트 사이드 JavaScript 언어 위에 올라가있는 기능들은 더 다양함
- API라고 부르는 이 기능들은 JavaScript 코드에서 사용할 수 있는 것들을 더 무궁무진하게 만들어 줌
- API
  1. **Browser APIs**
  2. Third party APIs
     - 브라우저에 탑재되지 않은 API
     - 웹에서 직접 코드와 정보를 찾아야 함
     - Google map api, kakao login api 등



#### Browser APIs

- 웹 브라우저에 내장된 API로, 웹 브라우저가 현재 컴퓨터 환경에 관한 데이터를 제공하거나, 오디오를 재생하는 등 여러가지 유용하고 복잡한 일을 수행할 수 있게 함
- JavaScript로 Browser API들을 사용해서 여러가지 기능을 사용할 수 있음



#### 브라우저가 웹 페이지를 불러오는 과정

- 웹 페이지를 브라우저로 불러오면, 브라우저는 코드(HTML, CSS, JavaScript)를 실행 환경(브라우저 탭)에서 실행
- JavaScript는 **DOM API**를 통해 HTML과 CSS를 동적으로 수정, 사용자 인터페이스를 업데이트하는 일에 가장 많이 쓰임



#### DOM (Document Object Model)

- 문서의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공
  - 문서 구조, 스타일, 내용 등을 쉽게 변경할 수 있게 도움
  - HTML 콘텐츠를 추가, 제거, 변경하고, 동적으로 페이지에 스타일을 추가하는 등 HTML/CSS를 조작할 수 있음
- HTML 문서를 구조화하여 각 요소를 객체(object)로 취급
- 단순한 속성 접근, 메서드 활용 뿐만 아니라 프로그래밍 언어적 특성을 활용한 조작이 가능함

- DOM은 문서를 논리 트리로 표현
- DOM 메서드를 사용하면 프로그래밍적으로 트리에 접근할 수 있고, 이를 통해 문서의 구조, 스타일, 컨텐츠를 변경할 수 있음

- DOM은 웹 페이지의 객체 지향 표현이며, JavaScript와 같은 스크립트 언어를 이용해 DOM을 수정할 수 있음



#### DOM의 주요 객체

- **window**

  - DOM을 표현하는 창
  - 가장 최상위 객체 (작성 시 생략 가능)
  - 탭 기능이 있는 브라우저에서는 각각의 탭을 각각의 window 객체로 나타냄

- **document**

  - 브라우저가 불러온 웹 페이지

  - 페이지 컨텐츠의 진입점 역할을 하며, `<body>` 등과 같은 수많은 다른 요소들을 포함하고 있음

  - document는 window의 속성이다

    ```
    > window.document		// #document
    ```

- navigator, location, history, screen 등



#### [참고] 파싱 (Parsing)

- 구문 분석, 해석
- 브라우저가 문자열을 해석하여 DOM Tree로 만드는 과정

---



## DOM 조작

- Document가 제공하는 기능을 사용해 웹 페이지 문서 조작하기
- DOM 조작 순서
  1. **선택 (Select)**
  2. **조작 (Manipulation)**
     - 생성, 추가, 삭제 등



#### 선택 관련 메서드

- **document.querySelector(selector)**
  - 제공한 선택자와 일치하는 element 한 개 선택
  - 제공한 CSS selector를 만족하는 첫 번째 element 객체를 반환 (없다면 null 반환)
- **document.querySelectorAll(selector)**
  - 제공한 선택자와 일치하는 여러 element를 선택
  - 매칭할 하나 이상의 셀렉터를 포함하는 유효한 CSS selector를 인자(문자열)로 받음
  - 제공한 CSS selector를 만족하는 NodeList를 반환



#### [참고] NodeList

- index로만 각 항목에 접근 가능
- 배열의 forEach 메서드 및 다양한 배열 메서드 사용 가능

- querySelectorAll()에 의해 반환되는 NodeList는 DOM의 변경사항을 실시간으로 반영하지 않음



#### 조작 관련 메서드

#### 생성

- **document.createElement(tagName)**
  - 작성한 tagName의 HTML 요소를 생성하여 반환

#### 입력

- **Node.innerText**
  - Node 객체와 그 자손의 텍스트 컨텐츠(DOMString)를 표현 (해당 요소 내부의 raw text)
  - 사람이 읽을 수 있는 요소만 남김
  - 즉, 줄 바꿈을 인식하고 숨겨진 내용을 무시하는 등 최종적으로 스타일링이 적용된 모습으로 표현됨

#### 추가

- **Node.appendChild()**
  - 한 Node를 특정 부모 Node의 자식 NodeList 중 마지막 자식으로 삽입
  - 한번에 오직 하나의 Node만 추가할 수 있음
  - 추가된 Node 객체를 반환
  - 만약 주어진 Node가 이미 문서에 존재하는 다른 Node를 참조한다면 현재 위치에서 새로운 위치로 이동

#### 삭제

- **Node.removeChild()**
  - DOM에서 자식 Node 제거
  - 제거된 Node 반환

#### 속성 조회 및 설정

- **Element.getAttribute(attributeName)**
  - 해당 요소의 지정된 값(문자열)을 반환
  - 인자(attributeName)는 값을 얻고자 하는 속성의 이름
- **Element.setAttribute(name, value)**
  - 지정된 요소의 값을 설정
  - 속성이 이미 존재하면 값을 갱신, 존재하지 않으면 지정된 이름과 값으로 새 속성을 추가

---



## Event

- 프로그래밍하고 있는 시스템에서 일어나는 사건(action) 혹은 발생(occurrence)으로, 각 이벤트에 대해 조작할 수 있도록 특정 시점을 시스템이 알려주는 것



#### Event object

- 네트워크 활동이나 사용자와의 상호작용 같은 사건의 발생을 알리기 위한 객체

- Event 처리는 줄 **addEventListener()** 라는 Event 처리기 (Event handler)를 다양한 html 요소에 부착해서 처리



#### Event handler - `addEventListener()`

- `EventTarget.addEventListener(type, listener[, options])`
  - 지정한 Event가 대상에 전달될 때마다 호출할 함수를 설정
  - Event를 지원하는 모든 객체(Element, Document, Window 등)를 대상(EventTarget)으로 지정 가능

- type
  - 반응 할 Event 유형을 나타내는 대소문자 구분 문자열
  - 대표 이벤트
    - input, click, submit, ...
- listener
  - 지정된 타입의 Event를 수신할 객체
  - JavaScript function 객체(콜백 함수)여야 함
  - 콜백 함수는 발생한 Event의 데이터를 가진 Event 객체를 유일한 매개변수로 받음



#### Event 취소

`event.preventDefault()`

- 현재 Event의 기본 동작을 중단
- HTML 요소의 기본 동작을 작동하지 않게 막음
- HTML 요소의 기본 동작 예시
  - a 태그 : 클릭 시 특정 주소로 이동
  - form 태그 : form 데이터 전송



#### this

- 어떠한 object를 가리키는 키워드
  - [참고] java에서의 this와 python에서의 self는 인스턴스 자기자신을 가리킴
- JavaScript는 해당 **함수 호출 방식**에 따라 this에 바인딩 되는 객체가 달라짐
- 즉, 함수를 선언할 때 this에 객체가 결정되는 것이 아니고, 함수를 호출할 때 **함수가 어떻게 호출되었는지에 따라 동적으로 결정됨**



#### 함수 문맥에서의 this

1. 단순 호출

   - 전역 객체를 가리킴
   - 전역은 브라우저에서는 window, Node.js는 global을 의미

   ```js
   const myFunc = function() {
     console.log(this)
   }
   myFunc()		// window
   ```

2. Method (Function in Object, 객체의 메서드로서)

   - 메서드로 선언하고 호출한다면, 객체의 메서드이므로 해당 객체가 바인딩

   ```js
   const myObj = {
     data: 1,
     myFunc() {
       console.log(this)	// myObj
       console.log(this.data)	// 1
     }
   }
   ```

3. Nested (Function 키워드)

   - forEach의 콜백 함수에서의 this가 메서드의 객체를 가리키지 못하고 전역 객체 window를 가리킴
   - 단순 호출 방식으로 사용되었기 때문

   ```js
   const myObj = {
     numbers: [1],
     myFunc() {
       console.log(this)		// myObj
       this.numbers.forEach(function (number) {
         console.log(number)	// 1
         console.log(this)		// window
       })
     }
   }
   ```

4. Nested (화살표 함수)

   - 이전에 일반 function 키워드와 달리 메서드의 객체를 잘 카리킴
   - 화살표 함수에서 this는 자신을 감싼 정적 범위
   - 자동으로 한 단계 상위의 scope의 context를 바인딩

   ```js
   const myObj = {
     numbers: [1],
     myFunc() {
       console.log(this)		// myObj
       this.numbers.forEach((number) => {
         console.log(number)	// 1
         console.log(this)		// myObj
       })
     }
   }
   ```



#### 화살표 함수

- 화살표 함수는 호출의 위치와 상관없이 상위 스코프를 가리킴 (Lexical scope this)
- **Lexical scope**
  - 함수를 어디서 호출하는지가 아니라 **어디에 선언**하였는지에 따라 결정
  - Static scope 라고도 하며 대부분의 프로그래밍 언어에서 따르는 방식
- 따라서 함수 내의 함수 상황에서 화살표 함수를 쓰는 것을 권장
- 하지만!! `addEventListener`의 콜백 함수에서는 function 키워드를 사용하기!!!!!!





