# 고급 타입

---

### 인터섹션 타입

- 두 타입에서 공통된 타입이 있다면 합칠 수 있음

```typescript
type Combinable = string | number;
type Numeric = number | boolean;

type Universal = Combinable & Numeric;
```

---

### 타입 가드

- 유니온 타입을 사용할 경우 각 상황에 맞도록 설정해주어 에러를 방지
- 특정 속성이나 메소드를 사용하기 전에 그것이 존재하는지 확인하거나 타입을 사용하기 전에 이 타입으로 어떤 작업을 수행할 수 있을지를 확인하는 개념
- 타입인 경우 `typeof` 키워드 사용
- 객체의 경우 `instanceof`나 `in` 키워드 사용

```typescript
class Car {
  drive() {
    console.log("Driving...");
  }
}

class Truck {
  drive() {
    console.log("Driving a truck...");
  }

  loadCargo(amount: number) {
    console.log("Loading cargo ..." + amount);
  }
}

type Vehicle = Car | Truck;

const v1 = new Car();
const v2 = new Truck();

function useVehicle(vehicle: Vehicle) {
  vehicle.drive();
  if (vehicle instanceof Truck) {
    vehicle.loadCargo(1000);
  }
}

useVehicle(v1);
useVehicle(v2);
```



#### 구별된 유니온 타입

- 리터럴 타입의 속성을 지정하고 `switch`문으로 제어 가능

```typescript
interface Bird {
  type: "bird";
  flyingSpeed: number;
}

interface Horse {
  type: "horse";
  runningSpeed: number;
}

type Animal = Bird | Horse;

function moveAnimal(animal: Animal) {
  let speed;
  switch (animal.type) {
    case "bird":
      speed = animal.flyingSpeed;
      break;
    case "horse":
      speed = animal.runningSpeed;
      break;
  }
  console.log("Moving with speed: " + speed);
}

moveAnimal({ type: "bird", flyingSpeed: 10 });
```

---

### 형 변환(type casting)

```typescript
// 방법 1
const userInputElement = <HTMLInputElement>document.getElementById('user-input');

// 방법 2
const userInputElement = document.getElementById('user-input') as HTMLInputElement;
```

---

### 인덱스 속성(Index Access Type)

- 정확한 속성 이름을 모르고 속성의 개수도 모르지만 타입은 알 때 사용!!
- 인덱스 속성 사용시 다른 속성도 전부 해당 타입이랑 같아야 함

```typescript
interface ErrorContainer {
  id: string;		// number 타입 지정 불가
  [prop: string]: string;
}

const errorBag: ErrorContainer = { 
  email: 'Not a valid email', 
  username: 'Must start with a character!' 
}
```

---

### 함수 오버로드

- 타입스크립트가 정확하게 어떤 타입인지 알지 못할 때 사용 (유니온 타입을 사용하는 경우)
- 유니온 타입을 사용하는 함수 위에 해당 함수의 경우의 수를 작성하면 됨

```typescript
type Combinable = string | number;

function addFn(a: number, b: number): number;
function addFn(a: string, b: string): string;
function addFn(a: string, b: number): string;
function addFn(a: number, b: string): string;
function addFn(a: Combinable, b: Combinable) {
  if (typeof a === "string" || typeof b === "string") {
    return a.toString() + b.toString();
  }
  return a + b;
}

const result = addFn("Max", " Schwarz");
result.split(" ");
```

---

### 옵셔널 체이닝 : `?`

- 객체 데이터의 중첩된 속성과 객체에 안전하게 접근할 수 있게 해줌
- `?` 키워드를 통해 해당 속성이 있으면 반환

```typescript
console.log(fetchedUserData?.job?.title);
```

---

### Null 병합 : `??`

-  빈 문자열이나 0이 아닌 `null` 혹은 `undefined`라면, fallback을 사용해야 한다는 의미
- 즉, `null`이나 `undefined`를 매끄럽게 처리해주는 연산자

```typescript
let userInput = '';
const storedData = userInput ?? 'DEFAULT';
console.log(storedData);		// ''

userInput = undefined;
console.log(storedData);		// 'DEFAULT'
```

