# 221109



## UX & UI

- 비슷한 것끼리 묶거나 내용을 구성해서 인지하는 것이 편하다고 느낌
- 단순한 느낌이나 심미적인 부분만 고려하는 것이 아닌 **체계적인 설계를 통해 기획**해야 한다



#### UX (User Experience)

- 유저와 가장 가까이에 있는 분야, 데이터를 기반으로 유저를 조사하고 분석해서 개발자, 디자이너가 이해할 수 있게 소통
- 유저가 느끼는 느낌, 태도 그리고 행동을 디자인
  - 백화점 1층에서 느껴지는 좋은 향수 향기
  - 로딩이 너무 길어서 사용하고 싶지 않았던 사이트 등



#### 좋은 UX를 설계하기 위해서는

- 사람들의 마음과 생각을 이해하고 정리해서 우리 제품에 녹여내는 과정이 필요
- 유저 리서치, 데이터 설계 및 정제, 유저 시나리오, 프로토타입 설계 등이 필요



#### UI (User Interface)

- 유저에게 보여지는 화면을 디자인
- UX를 고려한 디자인을 반영, 이 과정에서 기능 개선 혹은 추가가 필요한 경우 Front-end 개발자와 가장 많이 소통



#### [참고] Interface

- 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점
  - 즉, 사용자가 기기를 쉽게 동작 시키는데 도움을 주는 시스템
- 우리 일상 속에 인터페이스 예시
  - CLI (Command-Line Interface)나 GUI (Graphic User Interface)를 사용해서 컴퓨터를 조작



#### 좋은 UI를 설계하기 위해서는

- 예쁜 디자인만 중요하다기 보다는 사용자가 보다 쉽고 편리하게 사용할 수 있도록 하는 부분까지 고려되어야 함
- 통일된 디자인을 위한 디자인 시스템, 소통을 위한 중간 산출물, 프로토타입 등이 필요
- UI 디자인에 있어 가장 중요한 것은 **협업**



#### 디자이너와 기획자 그리고 개발자

- 많은 회사에서 UX/UI 디자인을 함께하는 디자이너를 채용하거나 UX는 기획자, UI는 디자이너의 역할로 채용하기도 함

- **UX (직무 : UX Researcher, User Researcher)**
  - (구글) 사용자의 경험을 이해하기 위한 통계 모델을 설계
  - (MS) 리서치를 기획하고 사용자에 대한 지표를 정의
  - (Meta) 정성적인 방법과 정량적인 방법을 사용해서 사용자 조사를 실시
- **UI (직무 : Product Designer, Interaction Designer)**
  - (구글) 다양한 디자인 프로토타이핑 툴을 사용해서 개발 가이드를 제공
  - (MS) 시각 디자인을 고려해서 체계적인 디자인 컨셉을 보여줌
  - (Meta) 제품을 이해하고 더 나은 UI Flow와 사용자 경험을 디자인

- 개발자는 단순히 기능 개발만 하는 사람이 아니며 제품에 대해 고민하고 소통하는 능력이 반드시 필요
- 즉, 다양한 분야와의 협업이 필수적이기에 기본적인 UX/UI에 대한 이해가 있어야 함

- 더 나은 UX/UI를 고민해볼 수 있는 웹사이트 : https://cantunsee.space/



#### 학문으로서의 UX & UI

- UX와 UI는 하나의 학문으로서 연구되고 있는 분야이며 심리학과도 밀접한 연관이 있음
- UX/UI 그리고 HCI
  - GUI : 유저가 보는 일반적인 시각적인 디자인
  - UI : 유저가 보거나 듣는 등 비시각적인 부분까지 포함한 디자인
  - UX : 유저가 겪는 모든 경험(컴퓨터와 관련이 없는 부분까지도 포함)
  - HCI(Human Computer Interaction) : 인간과 컴퓨터 사이의 상호작용에 대한 학문
- 기술은 복잡해져도 유저에 대한 경험은 단순해져야 됨

- Apple의 UI 디자인 원칙 (https://developer.apple.com/kr/design/tips/)

---



## Prototyping

#### Software prototyping

- 애플리케이션의 프로토타입을 만드는 것
- 즉, 개발 중인 소프트웨어 프로그램의 완성되기 전 버전을 만드는 것
- 한 번에 완성 버전이 나올 수 없기에 중간마다 현재 상태를 체크하는 과정



#### Prototyping Tool 시장

- 이전까지는 Sketch라는 툴이 굉장히 많이 사용되었지만, 현재는 **Figma**라는 툴이 약 70% 시장 점유율을 보이고 있음



#### Figma

- 인터페이스 디자인을 위한 협업 웹 애플리케이션
- **협업**에 중점을 두면서 UI/UX 설계에 초점을 맞춤



#### Why Figma?

- 웹 기반 시스템을 가짐 (웹 환경에서 동작)
  - 매우 가벼운 환경에서 실행 가능, 모든 작업 내역이 웹에 저장됨
- **실시간으로 팀원들이 협업**할 수 있는 기능을 제공
- 직관적이고 다양한 디자인 툴을 제공
- Figma 사용자들이 만든 다양한 플러그인이 존재 (VSCode의 확장프로그램 등)
- **대부분의 기능을 무료로 사용**



#### 프로젝트를 시작하기 전에

- 개발부터 시작하지 말고 반드시 충분한 **기획**을 거칠 것
- 우리가 완성하고자 하는 대략적인 모습을 그려보는 과정이 필요 (프로토타입)
- 이러한 과정을 통해서 기획에서 빠진 화면이나 API 등을 확인할 수 있음
- 설계와 기획이 끝난 후 개발을 시작해야 체계적인 진행이 가능함

---



## Routing

- 네트워크에서 경로를 선택하는 프로세스
- 웹 서비스에서의 라우팅
  - 유저가 방문한 URL에 대해 적절한 결과를 응답하는 것
- 예시
  - /articles/index/에 접근하면 articles의 index에 대한 결과를 보내줌



#### Routing in SSR

- Server가 모든 라우팅을 통제
- URL로 요청이 들어오면 응답으로 완성된 HTML 제공
  - Django로 보낸 요청의 응답 HTML은 완성본인 상태였음
- 결론적으로, Routing(URL)에 대한 결정권을 서버가 가짐



#### Routing in SPA / CSR

- 서버는 하나의 HTML (index.html) 만을 제공
- 이후에 모든 동작은 하나의 HTML 문서 위에서 JavaScript 코드를 활용
  - DOM을 그리는데 필요한 추가적인 데이터가 있다면 axios와 같은 AJAX 요청을 보낼 수 있는 도구를 사용하여 데이터를 가져오고 처리
- 즉, **하나의 URL만 가질 수 있음**



#### Why routing?

- Routing이 없다면,
  - 유저가 URL을 통한 페이지의 변화를 감지할 수 없음
  - 페이지가 무엇을 렌더링 중인지에 대한 상태를 알 수 없음
    - 새로고침 시 처음 페이지로 돌아감
    - 링크를 공유할 시 처음 페이지만 공유 가능
  - 브라우저의 뒤로 가기 기능을 사용할 수 없음

​	==> UX 관점에서 Routing이 필요함



#### Vue Router

- Vue의 공식 라우터
- 라우트(routes)에 컴포넌트를 매핑한 후, 어떤 URL에서 렌더링 할지 알려줌
  - 즉, SPA를 MPA처럼 URL을 이동하면서 사용 가능
  - SPA의 단점 중 하나인 **"URL이 변경되지 않는다."를 해결**
- [참고] MPA (Multiple Page Application)
  - 여러 개의 페이지로 구성된 애플리케이션
  - SSR 방식으로 렌더링

```
$ vue create vue-router-app		// Vue 프로젝트 생성
$ cd vue-router-app				// 디렉토리 이동
$ vue add router				// Vue CLI를 통해 router plugin 적용
```



#### History mode

- 브라우저의 History API를 활용한 방식
  - 새로고침 없이 URL 이동 기록을 남길 수 있음
- 우리에게 익숙한 URL 구조로 사용 가능
  - 예시) http://localhost:8080/index
- [참고] History mode를 사용하지 않으면 Default 값인 hash mode로 설정됨 ('#'을 통해 URL을 구분하는 방식)
  - 예시) http://localhost:8080#index



#### router-link

- a 태그와 비슷한 기능 --> URL을 이동시킴
  - routes에 등록된 컴포넌트와 매핑됨
  - 히스토리 모드에서 router-link는 클릭 이벤트를 차단하여 a 태그와 달리 브라우저가 페이지를 다시 로드 하지 않도록 함
- 목표 경로는 **'to'** 속성으로 지정됨
- 기능에 맞게 HTML에서 a 태그로 rendering 되지만, 필요에 따라 다른 태그로 바꿀 수 있음



#### router-view

- 주어진 URL에 대해 일치하는 컴포넌트를 렌더링 하는 컴포넌트
- 실제 component가 DOM에 부착되어 보이는 자리를 의미
- router-link를 클릭하면 routes에 매핑된 컴포넌트를 렌더링
- Django에서의 block tag와 비슷함
  - App.vue는 base.html의 역할
  - router-view는 block 태그로 감싼 부분



#### src/router/index.js

- 라우터에 관련된 정보 및 설정이 작성 되는 곳
- Django에서의 urls.py에 해당
- routes에 URL과 컴포넌트를 매핑



#### src/Views

- router-view에 들어갈 component 작성
- 기존에 컴포넌트를 작성하던 곳은 components 폴더 뿐이었지만 이제 두 폴더로 나뉘어짐
- 각 폴더 안의 .vue 파일들이 기능적으로 다른 것은 아님 (경로만 다름)

- 라우팅에 직접적으로 연결된 component는 src/Views에 작성, 라우팅과 직접적으로 연결되지 않은 component는 components 폴더에 작성



- **Views/**
  - routes에 매핑되는 컴포넌트, 즉 `<router-view>`의 위치에 렌더링 되는 컴포넌트를 모아두는 폴더
  - 다른 컴포넌트와 구분하기 위해 View로 끝나도록 만드는 것을 권장
    - ex) App 컴포넌트 내부의 AboutView & HomeView 컴포넌트
- **components/**
  - routes에 매핑된 컴포넌트의 하위 컴포넌트를 모아두는 폴더
    - ex) HomeView 컴포넌트 내부의 HelloWorld 컴포넌트

---



## Vue Router 실습

#### 선언적 방식 네비게이션

- router-link의 **'to'** 속성으로 주소 전달
  - routes에 등록된 주소와 매핑된 컴포넌트로 이동

```vue
<router-link :to="{ name: 'home' }">Home</router-link> |
<router-link :to="{ name: 'about' }">About</router-link>
```



#### 프로그래밍 방식 네비게이션

- Vue 인스턴스 내부에서 라우터 인스턴스에 **$router**로 접근 할 수 있음
- 다른 URL로 이동하려면 **this.$router.push**를 사용
  - history stack에 이동할 URL을 넣는(push) 방식
  - history stack에 기록이 남기 때문에 사용자가 브라우저의 뒤로 가기 버튼을 클릭하면 이전 URL로 이동할 수 있음

- 결국 `<router-link :to="...">`를 클릭하는 것과 **$router.push(...)**를 호출하는 것은 같은 동작



#### Dynamic Route Matching

- 동적 인자 전달
  - URL의 특정 값을 변수처럼 사용할 수 있음
- ex) Django에서의 variable routing

```vue
// App.vue
<router-link :to="{ name: 'hello', params: { userName: 'harry' } }">Hello</router-link>
```



#### route에 컴포넌트를 등록하는 또다른 방법

- 기존 방식

```js
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
```

- Lazy-loading

```js
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
  },
```



#### lazy-loading

- 모든 파일을 한 번에 로드하려고 하면 모든 걸 다 읽는 시간이 매우 오래 걸림
- 미리 로드를 하지 않고 특정 라우트에 방문할 때 매핑된 컴포넌트의 코드를 로드하는 방식을 활용할 수 있음
  - 모든 파일을 한 번에 로드하지 않아도 되기 때문에 최초에 로드하는 시간이 빨라짐
  - 당장 사용하지 않을 컴포넌트는 먼저 로드하지 않는 것이 핵심

---



## Navigation Guard

#### 네비게이션 가드

- Vue router를 통해 특정 URL에 접근할 때 다른 url로 redirect를 하거나 해당 URL로의 접근을 막는 방법
  - ex) 사용자의 인증 정보가 ㅇ벗으면 특정 페이지에 접근하지 못하게 함
- https://v3.router.vuejs.org/guide/advanced/navigation-guards.html



#### 네비게이션 가드의 종류

- 전역 가드
  - 애플리케이션 전역에서 동작
- 라우터 가드
  - 특정 URL에서만 동작
- 컴포넌트 가드
  - 라우터 컴포넌트 안에 정의



#### 전역 가드 (Global Before Guard)

- 다른 url 주소로 이동할 때 항상 실행
- router/index.js에 **router.beforeEach()**를 사용하여 설정
- 콜백 함수의 값으로 다음과 같이 3개의 인자를 받음
  - **to** : 이동할 URL 정보가 담긴 Route 객체
  - **from** : 현재 URL 정보가 담긴 Route 객체
  - **next** : 지정한 URL로 이동하기 위해 호출하는 함수
    - 콜백 함수 내부에서 반드시 한 번만 호출되어야 함
    - 기본적으로 to에 해당하는 URL로 이동

- URL이 변경되어 화면이 전환되기 전 **router.beforeEach()**가 호출됨
  - 화면이 전환되지 않고 대기 상태가 됨
- 변경된 URL로 라우팅하기 위해서는 **next()**를 호출해줘야 함
  - **next()가 호출되기 전까지 화면이 전환되지 않음**



#### 라우터 가드

- 전체 route가 아닌 특정 route에 대해서만 가드를 설정하고 싶을 때 사용
- **beforeEnter()**
  - route에 진입했을 때 실행됨
  - 라우터를 등록한 위치에 추가
  - 단, 매개변수, 쿼리, 해시 값이 변경될 때는 실행되지 않고 다른 경로에서 탐색할 때만 실행됨
  - 콜백 함수는 to, from, next를 인자로 받음



#### 컴포넌트 가드

- 특정 컴포넌트 내에서 가드를 지정하고 싶을 때 사용
- **beforeRouteUpdate()**
  - 해당 컴포넌트를 렌더링하는 경로가 변경될 때 실행

- Params 변화 감지

  - 변화하지 않는 이유
    - 컴포넌트가 재사용되었기 때문
    - 기존 컴포넌트를 지우고 새로 만드는 것보다 효율적
      - 단, lifecycle hook이 호출되지 않음
      - 따라서 $route.params에 있는 데이터를 새로 가져오지 않음

- beforeRouteUpdate()를 사용해서 처리

  - userName을 이동할 params에 있는 userName으로 재할당

  ```vue
  beforeRouteUpdate(to, from, next) {
    this.userName = to.params.userName
    next()
  }
  ```

- 해당 컴포넌트를 렌더링하는 경로가 변경될 때 실행



#### [참고] Optional Chaining

- Optional Chaining(**?.**) 앞의 평가 대상이 undefined나 null이면 에러가 발생하지 않고 undefined를 반환
  (ES 2020에서 추가된 문법)



#### Date in JavaScript

- JavaScript에서 시간을 나타내는 Date객체는 1970년 1월 1일 UTC(협정 세계시) 자정과의 시간 차이를 밀리초로 나타내는 정수 값을 담음
  - **Date().toLocaleString()**을 사용하여 변환
- 로컬 시간으로 변환해주는 computed 값 작성 및 출력

```vue
// views/DetailView.vue

<script>
export default {
  computed: {
    ...
    articleCreatedAt() {
      const article = this.article
      const createdAt = new Date(article?.createdAt).toLocaleString()
      return createdAt
    }
  },
}
</script>
```













































