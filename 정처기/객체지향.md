# 객체지향(Object-Oriented)

- 객체지향은 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있음
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 용이

---

## 객체지향 구성요소 (객체, 클래스, 메시지)

#### 객체(Object)

- 객체는 데이터와 데이터를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈
- 데이터
  - 객체가 가지고 있는 정보로, 속성이나 상태, 분류 등
- 함수
  - 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘
  - 객체의 상태를 참조하거나 변경하는 수단



#### 클래스(Class)

- 클래스는 공통된 속성과 연산을 갖는 객체의 집합
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 클래스에 속한 각각의 객체를 인스턴스(Instance)라고 함



#### 메시지(Message)

- 메시지는 객체들 간의 상호작용에 사용되는 수단으로, 객체의 동작이나 연산을 일으키는 외부의 요구 사항
- 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환

---

## 객체지향 특징

#### 추상화(Abstraction)

- 추상화는 **객체의 공통적인 속성과 기능을 모아 추출하여 정의**하는 것
- 보다 유연하고 변경에 열려있는 프로그램을 설계하기 위해 **역할과 구현을 분리하는 과정**
- `인터페이스`
  - 인터페이스에는 추상 메서드나 상수를 통해 **어떤 객체가 수행해야 하는 핵심적인 역할만을 규정**
  - 실제적인 구현은 인터페이스를 구현하는 각각의 객체들에서 하도록 프로그램을 설계



#### 캡슐화(Encapsulation)

- 캡슐화는 외부에서의 접근을 제한하기 위해 **인터페이스를 제외한 세부 내용을 은닉**하는 것
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적음
- 객체들 간에 메시지를 주고 받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 **인터페이스가 단순**해지고, **객체간의 결합도가 낮아짐**



#### 상속(Inheritance)

- 상속은 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
- 하위 클래스는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용 가능
- 하위 클래스는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용 가능



#### 다형성(Polymorphism)

- 다형성은 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
- 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함
- 즉, **어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질**
- 대표적인 예) 메서드 오버라이딩, 메서드 오버로딩



#### 연관성(Relationship)

- 연관성은 두 개 이상의 객체들이 상호 참조하는 관계를 의미

---

## 객체 지향 프로그래밍의 장점

- **코드의 변경을 최소화하고 유지보수를 하는데 유리**
  - 각각의 코드가 독립적인 역할을 가지기 때문
- **코드의 재사용성을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현 가능**
- **인간 친화적이고 직관적인 코드**

---

## 접근제어자

| 접근제어자 | 클래스 내 | 패키지 내 | 다른 패키지의 하위 클래스 | 패키지 외 |                         설명                         |
| :--------: | :-------: | :-------: | :-----------------------: | :-------: | :--------------------------------------------------: |
|  private   |     O     |     X     |             X             |     X     |            동일 클래스 내에서만 접근 가능            |
|  default   |     O     |     O     |             X             |     X     |            동일 패키지 내에서만 접근 가능            |
| protected  |     O     |     O     |             O             |     X     | 동일 패키지 + 다른 패키지의 하위클래스에서 접근 가능 |
|   public   |     O     |     O     |             O             |     O     |                    접근 제한 없음                    |

---

## 객체지향 설계원칙 : SOLID

#### 단일 책임 원칙 (SRP; Single Responsibility Principle)

- 한 클래스는 하나의 책임만을 가져야 한다.



#### 개방 폐쇄 원칙 (OCP; Open Close Principle)

- 확장에는 열려있고, 수정에는 닫혀있어야 한다.



#### 리스코프 치환 원칙 (LSP; Liskov Substitution Principle)

- 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.



#### 인터페이스 분리 원칙 (ISP; Interface Segregation Principle)

- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.



#### 의존성 역전 원칙 (DIP; Dependency Inversion Principle)

- 의존 관계를 맺을 때 자주 변화하는 것보다, 변화가 거의 없는 것에 의존해야 한다.

