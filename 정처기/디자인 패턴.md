# 디자인 패턴



## 디자인 패턴 용도

- 생성 패턴
- 행동 패턴
- 구조 패턴

---



## 생성 패턴 (Creational Pattern) - 5개

- 객체 인스턴스를 생성하는 패턴으로, 클라언트와 그 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어주는 패턴



#### 싱글턴 패턴 (Singleton Pattern)

- 특정 클래서에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴
- 싱글턴 패턴을 사용하면 전역 변수를 사용할 때와 마찬가지로 객체 인스턴스를 어디서든 액세스 가능
- 클래스 인스턴스를 하나만 만들고 그 인스턴스로의 전역 접근을 제공



#### 추상 팩토리 패턴 (Abstract Factory Pattern)

- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공
- 구상 클래스는 서브 클래스에서 만듦



#### 팩토리 메소드 패턴 (Factory Method Pattern)

- 객체를 생성할 때 필요한 인터페이스를 만듦
- 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정
- 팩토리 메소드 패턴들 사용하면 클래스 인스턴스를 만드는 일을 서브클래스에게 맡기게 됨
- 결합도를 낮추는 목적



#### 빌더 패턴 (Builder Pattern)

- 



#### 프로토타입 패턴 (Prototype Pattern)

- 미리 만들어진 객체를 복사해서 객체를 생성하는 방식



---



## 행동 패턴 (Behavioral Pattern) - 11개

- 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴



#### 템플릿 메소드 패턴 (Template Method Pattern)

- 알고리즘의 골격을 정의
- 템플릿 메소드 패턴을 사용하면 알고리즘 일부 단계를 서브클래스에서 구현할 수 있으며, 알고리즘의 구조는 그대로 유지하면서 알고리즘의 특정 단계를 서브클래스에서 재정의 가능



#### 상태 패턴 (State Pattern)

- 상태 패턴을 사용하면 객체 내부의 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있음
- 즉, 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있음



#### 반복자 패턴 (Iterator Pattern)

- 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법 제공



#### 전략 패턴 (Strategy Pattern)

- 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 사용할 수 있도록 해줌
- 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경 가능



#### 옵저버 패턴 (Observser Pattern)

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고, 자동으로 내용이 갱신되는 방식
- 일대다 의존성을 정의
- 상태 변화에 따른 처리를 기술할 때 효과적으로 활용 (MVC 패턴에서 Model과 View의 분리 등)



#### 책임 연쇄 패턴 (Chain-of-Responsibility Pattern)

- Handler 객체가 문제를 해결했는지 확인하면서 계속해서 가능한 객체를 연결해줌
- 용도
  - 어떤 요구 발생시 그 요구를 처리할 Object를 바로 결정할 수 없을 때, 다수의 Object를 Chain으로 연결해 차례로 방문하면서 목적에 맞는 Object를 결정



#### 커맨트 패턴 (Command Pattern)

- 명령어를 객체에 캡슐화해 저장 (주로 스택으로 저장)
- 용도
  - 실행하고 싶은 메소드의 History 관리
  - 매크로 명령을 정의하고자 할 때
  - 동일한 명령을 반복해서 실행할 때



#### 인터프리트 패턴 (Interpreter Pattern)



#### 중재자 패턴 (Mediator Pattern)

- 각 객체와 중재자를 연결
- 용도
  - 모든 행동을 수행하기 전에 '중재자 객체'의 결정이 있어야 하고, 중재자 객체로 프로그램이 수행됨
  - 각 객체들은 중재자만 알게됨



#### 메멘토 패턴 (Memento Pattern)

---



## 구조 패턴 (Structural Pattern) - 7개

- 클래스와 객체를 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴



#### 데코레이터 패턴 (Decorator Pattern)

- 데코레이터 패턴으로 객체에 추가 요소를 동적으로 더할 수 있음
- 데코레이터를 사용하면 서브클래스를 만들때보다 훨씬 유연하게 기능 확장 가능



#### 프록시 패턴 (Proxy Pattern)

- 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공



#### 컴포짓 패턴 (Composite Pattern)

- 컴포짓 패턴으로 객체를 트리구조로 구성해서 부분-전체 계층구조를 구현
- 컴포짓 패턴을 사용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있음



#### 어댑터 패턴 (Adapter Pattern)

- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환
- 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있도록 도와줌
- 즉, 어댑터는 다른 곳에서 개발한 클래스를 우리에게 맞게 중간에서 변환하는 역할을 해주는 클래스



#### 퍼사드 패턴 (Facade Pattern)

- 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어줌
- 복잡하게 얽혀있는 클래스들을 정리해서 고수준 인터페이스(API)로 정의하므로 서브시스템을 더 편리하게 사용 가능



#### 브릿지 패턴 (Bridge Pattern)

- 구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 한 형태
- 즉, 기능과 구현에 대해서 두 개를 별도의 클래스로 구현



#### 플라이웨이트 패턴 (Flyweight Pattern)







