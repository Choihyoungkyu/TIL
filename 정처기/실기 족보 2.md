# 정처기 실기 족보 2

---

## 알고리즘 설계 기법

1. 동적 계획법 (Dynamic Programming)
   - 어떤 문제를 해결하기 위해 그 문제를 더 작은 문제의 연장선으로 생각하는 Bottom-Up 방식
   - 작은 문제 해를 활용해서 큰 문제의 해를 찾는다
2. 탐욕적 알고리즘 (Greedy Algorithm)
   - 분기마다 가장 최적의 해를 선택하여 결과를 도출하는 방식
   - 반드시 종합적인 최적 해를 보장하지 않는다
3. 재귀적 알고리즘 (Recursive Algorithm)
   - 풀이 도중 같은 풀이를 다시 불러오는 과정을 반복하는 방식
4. 근사 알고리즘 (Approximation Algorithm)
   - 최적화되는 답을 구할 수는 없어도 비교적 빠른 시간에 계산이 가능하도록 근사 해법을 수행하는 알고리즘
5. 분할 정복법 (Divide and Conquer)
   - 크고 방대한 문제를 효율적으로 풀 수 있는 단위로 작게 나누는 Top-Down 방식
   - 계산된 결과를 다시 합쳐 큰 문제의 결과를 구함
6. 퇴각 검색법 (Backtracking)
   - 분기구조 탐색에서 탐색을 실패하는 경우, 탐색이 성공했던 이전 분기로 돌아가는 방식
   - DFS, BFS 등이 있음

---

## 오버로딩 vs 오버라이딩

- 객체지향 기술 캡슐화, 추상화, 상속, 다형성 중 다형성에 속하는 성질
- 상속된 여러 하위 객체들이 서로 다른 형태를 가질 수 있는 성질

1. 오버로딩
   - 동일한 이름의 여러 메소드 중, 매개변수로 전달되는 인수의 타입과 개수를 식별해 적절한 메서드를 호출하는 기능
2. 오버라이딩
   - 상속 받은 메서드의 내부 기능을 새롭게 정의하는 기능

---

## 럼바우 (Rumbaugh) 객체지향 분석 순서(객동기)

1. **객체(정보) 모델링**
   - 업무영역에서 객체를 식별하는 단계
   - 식별된 객체에 포함될 속성과 메서드를 식별
   - 속성에 사용될 자료구조를 표현
   - **객체 다이어그램**을 통해 객체를 표현
2. **동적 모델링**
   - 객체 모델링에서 생성된 객체들의 기능과 상태 등을 파악하는 단계
   - 사건, 상태, 조건, 활동들을 파악해 표시
   - **상태 다이어그램**을 통해 기능의 흐름을 표시
   - 입력 출력값
3. **기능 모델링**
   - 사용자 요구사항을 분석하여 입출력 데이터를 결정
   - 객체들의 제어 흐름, 기능의 상호작용 순서를 **자료흐름도(DFD)**로 나타냄
   - 각 기능을 세부적으로 상세히 분석

---

## 객체지향 설계 원칙 (SOLID)

1. 단일 책임 원칙 (SRP; Single Responsibility Principle)
   - 한 클래스는 하나의 책임만을 가져야한다
2. 개방 폐쇄 원칙 (OCP; Open-Closed Principle)
   - 확장에는 열려있고, 수정에는 닫혀 있어야 한다
3. 리스코프 치환 원칙 (LSP; Liskov Substitution Principle)
   - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다
4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
   - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다
5. 의존성 역전 원칙 (DIP; Dependency Inversion Principle)
   - 의존 관계를 맺을 때 자주 변화하는 것보다, 변화가 거의 없는 것에 의존해야 한다

---

## 레지스터 (Register)

- 레지스터는 CPU 내에서 발생 및 사용되는 데이터를 일시적으로 저장하는 저장장치
- 가격대비 용량이 가장 작고, 기억장치 중 속도가 가장 빠름
- 플립플롭(Flip-FLOP)과 래치(Latch)로 구분됨



#### 레지스터 종류

1. 제어장치 (CU) : 산술 및 논리 연산 등의 연산기능을 수행할 때 사용되는 레지스터
2. 연산장치 (ALU) : 명령어 수행에 필요한 데이터를 저장하는 레지스터
3. 메모리 주소 레지스터 (MAR) : 주기억장치 내에 출입하는 데이터의 번지를 기억
4. 메모리 버퍼 레지스터 (MBR) : 주기억장치 내에 출입하는 데이터가 잠시 저장
5. 프로그램 카운터 (PC) : 다음에 실행할 명령어들의 번지를 보관
6. 명령 레지스터 (IR) : 현재 실행중인 명령어를 임시 보관
7. 번지 레지스터 (AR) : 주기억장치의 번지를 기억
8. 데이터 레지스터 : 연산에 사용될 데이터를 기억
9. 상태 레지스터 : 연산 중 발생되는 이벤트 상태를 기억
10. 인덱스 레지스터 : 주소 변경을 위해 사용되는 레지스터

---

## 시스템 버스 (Bus)

- 주변 장치 간 정보 교환을 위해 연결된 통신 회선
- 내부 버스 : CPU 내부 요소 사이의 정보를 전송하는 버스
- 외부 버스 : CPU와 주변장치간 정보를 전송하는 버스



#### 외부 버스 종류

- 주소 버스 : 하나의 장치로부터 다른 장치로 주소 데이터를 전달하는 단방향 회선
- 데이터 버스 : 장치 간 서로 데이터를 교환하기 위한 양방향 회선
- 제어 버스 : CPU가 주변 장치에게 제어 신호를 전달하는 단방향 회선

---

## 운영체제에서의 시간

- 응답 시간 (Response Time) : 작업이 입력되고 처음 실행되기 전까지 걸린 시간
- 대기 시간 (Waiting Time) : 작업이 입력되고 완료되기 전까지의 시간 중 작업이 진행되지 않은 시간의 합
- 실행 시간 (Running Time) : 작업이 입력되고 완료되기 전까지의 시간 중 작업이 진행된 시간의 합
- 반환 시간 (Turn around Time) : 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때까지 걸린 시간의 합
- 시간 간격 (Time Slice, Quantum) : 프로세스가 자원을 사용하기 위해 운영체제로부터 할당받은 시간

---

## 운영체제 자원 관리

- 프로세스 관리 : 프로세스의 생성과 제거, 시작과 정비, 스케줄링 등을 담당
- 기억장치 관리 : 프로세스에게 메모리 할당 및 회수 등 담당
- 주변장치 관리 : 입출력 장치의 스케줄링 및 관리를 담당
- 파일 관리 : 파일의 생성과 삭제, 변경, 유지 등의 관리를 담당

---

## 유닉스 (UNIX)

- C 언어를 기반으로 제작됨. 이식성이 우수함
- 하나 이상의 작업을 병행 처리할 수 있고 둘 이상의 사용자가 동시에 시스템을 사용할 수 있음
- 표준이 정해져 있고 제품의 공급 업체가 많으며 라이선스 비용이 저렴함
- 계층적 파일 시스템과 풍부한 네트워킹 기능이 존재
- 쉘 명령어 프로그램과 사용자 위주의 시스템 명령어가 제공됨



#### 유닉스 기본 구성

- 커널 (Kernel)
  - 유닉스의 핵심 요소로 핵심 시스템을 관리하고 서비스를 제공
  - 하드웨어 보호, 사용자 서비스 제공, 프로세스, 메모리, 네트워크, 입출력, 파일 관리 등을 제공
- 쉘 (Shell)
  - 사용자 명령의 입력을 받아서 시스템 기능을 수행하는 명령 해석기
  - 사용자와 커널 사이에서 중계자 역할, 인터페이스를 담당
- 유틸리티 (Utility)
  - 문서 편집, 데이터베이스 관리, 언어 번역, 네트워크 기능을 제공



#### 커널의 종류

- 마이크로(Micro) 커널
  - 시스템 운영에 필요한 최소한의 기능들만 제공
  - 사용자가 필요한 기능을 추가하여 운영체제를 확장할 수 있도록 함
- 모놀리식(Monolithic) 커널
  - 구현이 간단하여 속도가 빠르다
  - 임의 기능을 적재하여 동적으로 사용할 수 없다

---

## 프로세스 (Process)

- 프로그램이 주기억 장치에 적재되어 CPU에 의해 실행 과정에 있는 것을 의미
- 목적 또는 결과에 따라 발생되는 사건(프로시저)들의 과정
- CPU가 할당되는 PCB가 정의하는 실체



#### 프로세스 주요 상태

1. 준비 상태 : 기억 장치에 존재하는 프로세스를 선택하여 CPU 할당을 기다리는 상태
2. 실행(Run) 상태 : 대기 상태의 프로세스가 CPU를 할당받아 작업이 진해오디는 상태
3. 대기(Block) 상태 : 프로세스의 특정 작업을 진행하기 위해 입출력 작업 등을 기다리는 상태
4. 종료(Exit) 상태 : 프로세스 실행이 완료되어 종료된 상태



#### 프로세스 상태 전이 과정

1. Dispatch : 준비 상태의 프로세스가 실행 상태로 변하는 과정
2. Time Run Out : 실행 상태의 프로세스가 할당된 시간을 모두 사용했지만 아직 작업을 끝내지 못한 경우 다시 준비 상태로 넘어가는 과정
3. Block : 실행 상태의 프로세스가 입출력에 의해 작업을 위해 대기 상태로 변하는 과정
4. Wake Up : 입출력 등이 완료되어 대기 상태의 프로세스가 준비 상태로 변하는 과정

---

## IPC (Inter Process Communication)

- 협력하는 프로세스들 사이에 서로 데이터를 주고 받는 행위 또는 그에 대한 방법, 경로를 의미
- 프로세스들의 자원 공유, 속도 향상, 모듈화 편의성 증대에 활동됨
- 메세지 교환 방식과 메모리 공유 방식으로 구분



#### IPC 구분

- 메모리 교환
  - 메모리 보호를 위해 커널이 대신 데이터 전달
  - 안전하지만 성능이 떨어짐
- 메모리 공유
  - 공유 메모리 생성
  - 성능이 우수하지만 동기화 문제 발생

---

## 스레드 (Thread)

- 프로세스 내의 작업단위
- 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위
- 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스라고도 함
- 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능

---

## 비선점형 (Non Preemption) 스케줄링

- 현재 실행 중인 프로세스를 다른 프로세스가 강제적으로 중단할 수 없는 방식
- CPU를 사용하는 현재 프로세스가 종료되면 다른 프로세스에 CPU를 할당
- 응답 시간의 예측이 용이하고, 일괄 처리 시스템에 적합함



#### 비선점형 스케줄링 알고리즘

- FIFO(First In First Out)
  - 프로세스가 도착한 순서대로 처리함
- SJF(Short Job First)
  - 실행시간이 가장 짧은 프로세스 순으로 처리
  - 실행시간이 긴 작업일 경우 무한 대기(기아) 상태가 발생할 수 있음
  - 짧은 시간의 작업들이 많은 경우 FIFO보다 평균 대기 시간이 작음
- HRN(Highest Response-ratio Next)
  - FIFO와 SJF의 단점을 보완하여 개발된 방법
  - 대기 시간이 긴 프로세스의 우선순위를 높여 긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있음
  - `우선순위 : (대기시간 + 실행시간) / (실행시간)`

---

## 선점형 (Preemption) 스케줄링

- 현재 실행 중인 프로세스를 다른 프로세스가 강제로 중단할 수 있는 방법
- 다른 프로세스가 현재 사용중인 프로세스를 중단시키고 CPU를 차지할 수 있음
- 빠른 응답 시간을 필요로 하는 대화식, 시분할, 실시간 처리에 적합함



#### 선점형 스케줄링 알고리즘

- RR(Round Robin)
  - 동일한 Time Slice를 사용하는 시분할 처리 시스템에 효과적
  - 주어진 Time Slice 동안만 순서대로 프로세스를 처리하는 방식
- SRT(Shortest Remaining Time)
  - 작업이 끝나지 않은 프로세스의 남아 있는 실행 시간이 가장 작은 프로세스를 먼저 실행하는 방식
  - SJF 기법을 선점 형태로 변경한 것
  - 점유 시간이 길어도 중요한 프로세스를 먼저 할당할 수 있음
- MFQ(Multilevel Feedback Queue)
  - 짧은 작업이나 입출력 위주의 프로세스에 우선순위를 부여하기 위해 개발된 방식
  - 우선순위가 있는 각 큐(대기 리스트)가 있으며 큐마다 Time Slice가 존재
  - 맨 마지막 단계의 큐는 RR 스케줄링 방식을 사용

---

## 교착상태 (DeadLock)

- 둘 이상의 프로세스가 실현 불가능한 상태를 무한정 기다리고 있는 상태
- 둘 이상의 프로세스가 하나의 자원을 서로 요구하는 상태



#### 교착상태(DeadLock) 조건

- 상호 배제 (Mutual Exclution) : 한 번에 한 개의 프로세스만이 공유자원을 사용할 수 있음
- 점유 대기 (Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
- 비선점 (No Preemption) : 이미 할당된 자원을 강제적으로 빼앗을 수 없음
- 순환 대기 (Circular Wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가진다



#### 교착상태(DeadLock) 해결 방안

- 예방 (Prevention) : 상호 배제 부정, 점유 대기 부정, 비선점 부정, 순환 대기 부정
- 회피 (Avoidance) : 안정적인 상태를 유지할 수 있는 프로세스의 요청만 받아들임. (ex. 은행원 알고리즘)
- 발견 (Detection) : 컴퓨터의 중단 원인이 교착상태인지 다른이유인지 파악하는 방법. 공유자원과 프로세스의 관계를 인접행렬로 파악
- 회복 (Recovery) : 교착상태가 발생한 프로세스 중 희생양(중단할 프로세스)를 정하여 자원을 뺏음
  - 우선순위가 낮은 프로세스
  - 진행률이 적은 프로세스
  - 자원을 적게 사용하는 프로세스
  - 기아 상태로 수행이 불가능한 프로세스

---

## 주기억 장치 할당 방법

#### 단일 분할 할당 기법

- 오버레이 기법
  - 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 방법
  - 프로그램을 여러 조각으로 나눈 후 필요한 조각을 주기억장치에 적재하여 프로그램을 실행
  - 주기억 장치 공간이 부족해지면 적재된 조각 중 불필요한 조각을 중첩 적재
  - 여러 조각으로 나누는 작업은 프로그래머가 직접 해야 함
- 스와핑 기법
  - 프로그램 전체를 할당하여 사용하다 필요에 따라 다른 프로그램으로 교체하는 기법
  - 사용자 프로그램이 완료될 때까지 교체 과정을 여러번 수행
  - Swap In : 보조기억장치에서 주기억장치로 프로그램을 이동하는 것
  - Swap Out : 주기억장치에서 보조기억장치로 프로그램을 이동하는 것

---

## 분산 처리 시스템 투명성

- 사용자가 분산된 여러 자원의 위치 정보를 알지 못하고 하나의 커다란 컴퓨터 시스템을 사용하는 것처럼 느끼게 하는 성질

1. 위치(Location) 투명성 : 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스
2. 중복(Replication) 투명성 : 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용 가능. 시스템은 자동으로 여러 자료에 대한 작업 수행
3. 병행(Concurrency) 투명성 : 다수의 트랜잭션이 동시에 실현되더라도 그 결과는 영향을 받지 않음
4. 장애(Failure) 투명성 : 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 트랜잭션을 정확히 처리함

---

#### 참고 사이트

- https://incomeplus.tistory.com/644

























