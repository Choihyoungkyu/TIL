# 2022년 2회



### 1. 다음 괄호에 들어갈 용어를 쓰시오

```
- 관계 데이터 모델의 제안자인 코드(E.F.Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안하였다.
- (   )은 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때 계산 수식을 사용.
- (   )은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성
```

```
ans : 관계해석

관계해석 : 비절차적 특성
관계대수 : 절차적 특성 - SELECT, PROJECT, JOIN, DIVISION
```



**DIVISION**

`<<R>>`

|  A   |  B   |
| :--: | :--: |
|  a1  |  b1  |
|  a1  |  b2  |
|  a1  |  b3  |
|  a2  |  b1  |
|  a2  |  b3  |

`<<S1>>`

|  B   |
| :--: |
|  b1  |

`<<S2>>`

|  B   |
| :--: |
|  b1  |
|  b2  |

- 예시1 : (R) DIVISION (S1)

|  A   |
| :--: |
|  a1  |
|  a2  |

- 예시2 : (R) DIVISION (S2) => b1, b2 둘 다 가지고 있는 것만!!

|  A   |
| :--: |
|  a1  |



### 2. 암호 방식에 따른 분류

#### 양방향 (기밀성)

- **대칭키** : 암호화키 = 복호화키, 데이터 암호 목적, 용량 Good, 속도 Good
  - **Stream 방**식 : 1 bit 씩 연산, XOR 연산
    - OTPad
    - RC4(PPTP, WEP, TKIP)
  - **Block 방식** : 2 bit 이상 묶음 연산
    - Festel 구조 : DES, 3DES
    - SPN 구조 : AES(요즘 사용)
    - 기타 : IDEA(유럽)
- **비대칭키(=공개키)** : 암호화키 != 복호화키, 대칭키 교환 용도, 용량 Bad, 속도 Bad
  - **인수분해** : RSA(디지털 서명, PGP), Robin
  - **이산대수** : DH(키교환), EIGmal, DSA(디지털 서명)
  - **타원곡선방정식** : ECC



#### 블록 암호 알고리즘

**AES**

- 128 bit 평문을 128/192/256 bit로 암호화
- 키 크기에 따라 10/12/14회 Round 수행
- 1997년 NIST에 의해 제정
- 레인달(Rijndael)에 기반한 암호화 방식
- SPN 암호 방식을 사용

**SEED**

- 순수 국내기술로 개발한 128 bit 및 256 bit 대칭키 블록 암호 알고리즘

**ARIA**

- 국가 보안 기술 연구소(NSRI) 필두로 하계, 국가 정보원 등의 암호 기술 전문가들이 개발한 국가 암호화 알고리즘
- AES 알고리즘과 똑같이 128/192/256 bit 암호화키를 지원한다
- SPN 암호 방식을 사용한다

**IDEA**

- 1990년 스위스에서 만들어진 PES를 개량하여 만들어진 블록 암호 알고리즘
- 키길이가 128bit, 블록길이가 64bit
- Feistel 방식과 SPN의 중간형태 구조



#### 스트림암호 알고리즘

- LFSR
- RC4
- A5



### 3. 다음에 설명하는 용어를 영문약어로 적으시오.

```
인터넷 등 통신 사업자의 공중 네트워크에 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안솔루션
```

```
ans : VPN
```



#### 보안 솔루션

- 방화벽 (Firewall)
  - 네트워크 간에 전송되는 정보를 선별하는 기능을 가진 침입 차단 시스템
- 웹방화벽 (Web Firewall)
  - 웹기반 공격을 방어할 목적으로 만들어진 웹서버 특화 방화벽
- 침입탐지 시스템 (IDS; Intrusion Detection System)
  - 컴퓨터 시스템의 비정상적인 사용, 오용 등을 실시간으로 탐지하는 시스템
  - 이상탐지, 오용탐지
- 침입방지 시스템 (IPS; Intrusion Prevention System)
  - 방화벽과 침입탐지 시스템을 결합한 것
- 데이터유출방지 (DLP; Data Leakage/Loss Prevention)
  - 내부 정보의 유출을 방지하기 위한 보안솔루션
- NAC (Network Access Control)
  - 네트워크에 접속하는 내부 PC의 MAC 주소(고유랜카드주소)를 IP관리 시스템에 등록한 후 일관된 보안관리 기능을 제공하는 보안솔루션
- ESM (Enterprise Security Management)
  - 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합관리 하는 보안 솔루션



### 4. 아래 설명에서 1~4에 해당하는 용어를 적으시오.

```
네트워크 집합을 몇 개의 그룹으로 나누었을 때 동일 그룹 내에서 라우팅 정보를 교환할 때 사용하는 라우팅 프로토콜을 ( 1 )라고 하고, 다른 그룹과 라우팅 정보를 교환하는 프로토콜을 ( 2 )라고 한다.
( 1 )의 대표적인 프로토콜은 RIP와 ( 3 )가 있고, ( 2 )의 대표적인 프로토콜은 ( 4 )이다.
```

```
ans : 1 - IGP, 2 - EGP, 3 - OSPF, 4 - BGP
```



#### 라우팅 프로토콜

```
														Routing Protocol
														________|________
													 |								 |
										Static Routing			Dynamic Routing
			 									 ____________________|_____________
		 									  |																	 |
			 								 IGP															  EGP
		 			 _____________|_____________										 |
		 			|														|										 |
		Distance Vector						Link-State Vector						 |
	 _______|_______						 _______|_______						 |
	|							  |						|								|						 |
 RIP						 IGRP				EIGRP						OSPF					BGP
```

- 동적 라우팅
  - IGP (내부 라우팅 프로토콜)
    - 거리 벡터 알고리즘 (횟수!!)
      - RIP : 최대 15홉 이동 가능
      - IGRP
    - 링크 상태 알고리즘 (가중치!!)
      - EIGRP
      - OSPF
  - EGP (외부 라우팅 프로토콜)
    - 내부에서 밖으로 빠져나가기 위한 프로토콜
    - BGP



### 5. 아래 1~2에서 설명하는 테스트 종류를 쓰시오.

```
( 1 )은 개발자의 통제 하에 사용자가 개발 환경에서 수행하는 테스트이다.
내부에서 진행하는 자체 검사로 실제 사용 환경에서 동작시키며 관련자만 참여한다.
( 2 )는 개발된 소프트웨어를 사용자가 실제 운영환경에서 수행하는 테스트이다.
( 1 )수행 이후 정식으로 출시하기 전 사용자에게 테스트를 하도록 한다.
```

```
ans : 1 - 알파 테스트, 2 - 베타 테스트
```



#### V 모델

```
단위 -> 통합 -> 시스템 -> 인수

단위 : 정적 or 동적 테스트
통합 : 하향식(스톱) or 상향식(드라이버) 테스트
시스템 : 기능 or 비기능 테스트
인수 : 알파 or 베타 테스트
```



### 6. 변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부를 평가하는 테스트는 무엇인지 보기에서 찾아 쓰시오.

```
ans : Regression

회귀 테스트 : 테스트 목적에 따른 분류 중 하나로, 수정된 코드에 대해 별 탈 없이 동작하는지를 보기 위한 테스트
```



#### 응집도 (Cohesion)

|    응집도     | 내용                                                         |
| :-----------: | ------------------------------------------------------------ |
| 기능적 응집도 | 모듈 내부의 모든 기능이 단일한 목적을 위해 수행              |
| 순차적 응집도 | 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용   |
| 통신적 응집도 | 동일한 입력과 출력을 사용하여 다른 기능을 수행               |
| 절차적 응집도 | 모듈 안의 구성요소들이 기능르 순차적으로 수행하는 경우       |
| 시간적 응집도 | 특정 시간에 처리되어야 하는 활동을 한 모듈에서 처리          |
| 논리적 응집도 | 유사한 성격을 갖거나 특정 형태로 분류되는 처리요소들이 한 모듈에서 처리 |
| 우연적 응집도 | 모듈 내부의 각 구성 요소들이 연관이 없는 경우                |

- **우**(우연적)리 **놀**(논리적)던 **시**(시간적)**절**(절차적)에 **통**(통신적)통한 **순**(순차적)대 **기**(기능적)가 막혔지



#### 결합도 (Coupling)

|      결합도       | 내용                                                         |
| :---------------: | ------------------------------------------------------------ |
| 자료(Data) 결합도 | 모듈간의 자료(값)를 통해서만 모듈 상호 작용 발생 (func(10))  |
|   스탬프 결합도   | 모듈간의 배열이나 오브젝트, 스트럭처 등이 전달되는 경우 (func(int* a)) (참조) |
|    제어 결합도    | 값만 전달되는게 아니라, 제어 요소가 전달 되는 경우 (if)      |
|    외부 결합도    | 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조             |
|    공통 결합도    | 전역변수를 참조                                              |
|    내용 결합도    | 다른 모듈 내부에 있는 변수나 기능을 또 다른 모듈에서 사용    |

- **테**(자료, 데이터)스형 **쟤**(제어) **왜**(외부)저래? **공**(공통)유랑 **내**(내용)가 닮았대!



### 8. 아래 1~3에서 해당하는 용어를 쓰시오.

```
( 1 )는 W3 상에서 정보를 주고받을 수 있는 프로토콜이다. GET, POST 방식을 이용하여 문서를 주고 받는데, 이 문서내에서 다른 문서를 링크정보가 들어가는데, 이런 링크 정보를 만들 수 있는게 ( 2 )이다.
이런 ( 2 )를 만들 수 있는 마크업언어가 ( 3 )이다.
```

```
ans : 1 - HTTP, 2 - Hypertext, 3 - HTML
```



#### WSDL, UDDI, SOAP

```
WSDL은 서비스의 설명서
UUDI는 설명서(WSDL)를 등록시키는 곳
SOAP은 설명서를 가지고 오기 위한 프로토콜
```



### 9. 객체지향 설계 원칙 중 아래에 설명하는 용어를 보기에서 찾아 쓰시오.

```
자신이 사용하지 않는 인터페이스는 구현하지 말아야 하고, 자신이 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다. 그러므로 인터페이스를 작게 나누어 만들어야 한다.
```

```
ans : 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
```



#### 객체지향 설계원칙 (SOLID)

- 단일 책임 원칙 (SRP, Single Responsibility Principle)
  - 한 클래스는 하나의 책임만을 가져야한다
- 개방 폐쇄 원칙 (OCP, Open-Closed Principle)
  - 확장에는 열려 있고, 수정에는 닫혀 있어야 한다
- 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
  - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다
- 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
  - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다
- 의존성 역전 원칙 (DIP, Dependency Inversion Principle)
  - 의존 관계를 맺을 때 자주 변화하는 것보다, 변화가 거의 없는 것에 의존해야 한다



#### UI 설계 원칙

- 직관성
  - 화면의 버튼, 항목, 입력란 등 누구나 쉽게 이해하고 사용할 수 있도록 한다
- 유효성
  - 사용자의 목적을 정확히 달성할 수 있도록 유용하고 효과적이어야 한다
- 학습성
  - 사용자가 쉽게 배우고 익힐 수 있어야 한다
- 유연성
  - 사용자의 요구를 최대한 수용하면서 오류를 최소화해야 한다



### 10. IP 주소가 192.168.100.132이고, 서브넷 마스크가 255.255.255.192인 경우 1~2에 해당하는 값을 쓰시오.

```
네트워크 주소 192.168.100.( 1 )
사용 가능한 주소 개수 ( 2 )
```

```
ans : 1 - 128, 2 - 62

192 -> 11000000 -> 00 -> 000000 ~ 111111 -> 0 ~ 63
									 01 -> 000000 ~ 111111 -> 64 ~ 127
									 10 -> 000000 ~ 111111 -> 128 ~ 191 => 132가 속한 부분
									 11 -> 000000 ~ 111111 -> 192 ~ 255
									 
네트워크 주소 : 맨 앞 부분
브로드캐스트 주소 : 맨 뒷 부분
사용 가능한 주소 개수 : 처음과 맨 뒤를 뺀 개수
```



### 11. 다음 직원 릴레이션에서, 다음 관계대수식을 실행한 결과를 1~5에 작성하시오.

| NAME | TTL  |
| :--: | :--: |
| LEE  | 부장 |
| KIM  | 대리 |
| SONG | 차장 |
| PARK | 과장 |

```
PROJECT TTL(직원)
```

|  1   |
| :--: |
|  2   |
|  3   |
|  4   |
|  5   |

```
ans : 1 - TTL, 2 - 부장, 3 - 대리, 4 - 차장, 5 - 과장

PROJECT(pi) : 해당하는 것을 그대로 가져오면 됨
```



### 12. 상품 테이블에서 B 제조사 전체 제품의 단가보다 더 큰 단가를 가진 제품을 모두 출력하는 SQL 문을 완성하시오.

```
SELECT * FROM 상품 
WHERE 단가 > ( 1 )
(
	SELECT 단가 FROM 상품
	WHERE 제조사='B'
)
```

```
ans : ALL

IN : 해당하는 값들에 속해있는지 확인 후 그 값을 출력
EXIST : 해당하는 값들에 속해있는지 확인 후 행만 가지고 옴 -> 성능 더 좋음
ALL : 해당하는 모든 값들에 대한 조건을 만족해야함
ANY : 하나라도 만족하면됨
```



### 13. 다음 릴레이션의 데이터는 다음과 같이 저장되어 있다. SQL을 수행했을 때 결과를 쓰시오.

| IDX  | COL1 | COL2 |
| :--: | :--: | :--: |
|  1   |  2   | NULL |
|  2   |  3   |  6   |
|  3   |  5   |  5   |
|  4   |  6   |  3   |
|  5   | NULL |  3   |

```
SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5)
```

```
ans : 4
```



### 14. 다음은 함수적 종속에 해당하는 설명이다. 1~3에 해당하는 용어를 보기에서 찾아 쓰시오.

```
- 함수적 종속관계에서 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우 이를 ( 1 )이라 한다.
- 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부만 종속되는 경우 이를 ( 2 )라고 한다.
- X->Y, Y->Z이란 종속 관계가 있을 경우, X->Z가 성립되는 경우를 ( 3 )라 한다.
```

```
ans : 1 - Full, 2 - Partial, 3 - Transitive

완전함수종속(Full)
부분함수종속(Partial)
이행적함수종속(Transitive)
```



#### 이상현상

- 삽입 이상
  - 릴레이션에서 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상
- 삭제 이상
  - 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄 삭제 현상
- 갱신 이상
  - 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상



#### 정규화 과정

- 비정규 Relation

  ​		V		-		도메인이 원자값 (하나의 칸에는 하나의 값만)

- 제1정규형

  ​		V		-		부분 함수적 종속 제거 (기본키가 여러 개일 경우 모든 기본키를 사용해야만 하나의 값을 알 수 있어야함)

- 제2정규형

  ​		V		-		이행적 함수 종속 제거 (X->Y->Z일 경우 X->Y, Y->Z로 분리해야함)

- 제3정규형

  ​		V		-		결정자이면서 후보키가 아닌 것 제거

- BCNF

  ​		V		-		다치 종속 제거

- 제4정규형

  ​		V		-		조인 종속성 이용

- 제5정규형



### 15. 다음 C언어 프로그램의 출력결과를 쓰시오.

```c
#include<stdio.h>
struct st{
  int x,y;
}
int main(){
  struct st dt[2];
  for(int i=0; i<2; i++){
    dt[i].x = i;
    dt[i].y = i+1;
  }
  printf("%d", dt[0].x + dt[1].y);
}
```

```
ans : 2
```



### 16. 다음 C언어 프로그램의 출력결과를 쓰시오.

```c
#include<stdio.h>
int main(){
  char *p1 = "2022";
  char *p2 = "202210";
  int i = func(p1);
  int j = func(p2);
  printf("%d", i+j);
  return 0;
}

int func(char *p){
  int cnt = 0;
  while(*p != `\0`){
    cnt++;
    p++;
  }
  return cnt;
}
```

```
ans : 10

p1 -> 2 0 2 2 \0 -> 4
p2 -> 2 0 2 2 1 0 \0 -> 6
```



### 17. 다음 C언어 프로그램의 출력결과를 쓰시오.

```c
#include<stdio.h>
int main(){
  int a[4] = {0, 2, 4, 8};
  int b[3];
  int *p;
  int sum=0;
  for(int i=1; i<4; i++){
    p = a+i;
    b[i-1] = *p - a[i-1];
    sum += b[i-1] + a[i];
  }
  printf("%d", sum);
}
```

```
ans : 22

4+6+12
```



### 18. 다음 JAVA 프로그램의 출력결과를 쓰시오.

```java
public static void main(String[] args) {
  int i = 3;
  int sum = 0;
  switch(i) {
    case 0: sum++;
    case 1: sum+=3;
    case 2: sum-=10;
    case 3: sum=0;
    case 4: sum+=3;
    case 5: sum-=10;
    default: sum--;
  }
  System.out.println(sum);
}
```

```
ans : -8
```



### 19. 다음 JAVA 프로그램의 출력결과를 쓰시오.

```java
class Cal {
  int a;
  Cal(int a){
    this.a = a;
  }
  int func(){
    int b=1;
    for(int i=1; i<a; i++)
      b = a*i + b;
    return a+b;
  }
}

public class Main{
  public static void main(String[] args){
    Cal obj = new Cal(3);
    obj.a = 5;
    int b = obj.func();
    System.out.println(obj.a + b);
  }
}
```

```
ans : 61

func() =>	b = 6, 16, 31, 51
					return 5 + 51 = 56
answer => 5 + 56 = 61
```



### 20. 다음 파이썬 코드에서 출력되는 결과를 작성하시오.

```python
str1 = "REMEMBER NOVEMBER"
str2 = str1[:3] + str1[12:16]
str3 = "R AND %s" % "STR"
print(str2 + str3)
```

```
ans : REMEMBER AND STR

str2 = "REMEMBE"
str3 = "R AND STR"
```

